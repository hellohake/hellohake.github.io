<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>博客搭建</title>
    <url>/post/f3fb008f.html</url>
    <content><![CDATA[<h1 id="hexo-github搭建静态博客"><a href="#hexo-github搭建静态博客" class="headerlink" title="hexo + github搭建静态博客"></a>hexo + github搭建静态博客</h1><ol>
<li>知乎参考：<a href="https://zhuanlan.zhihu.com/p/26625249?utm_source=qq&utm_medium=social">基本设置</a></li>
<li>csdn博客1：<a href="https://blog.csdn.net/qq_35396510/article/details/105953460">next7.8.0</a></li>
<li>csdn博客2: <a href="https://blog.csdn.net/tuckEnough/article/details/107383201?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-6.control&dist_request_id=1331979.14715.16186627507542321&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-6.control">next7.8.0</a></li>
</ol>
<h2 id="1-工具准备"><a href="#1-工具准备" class="headerlink" title="1.工具准备"></a>1.工具准备</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.安装node.js , hexo , git</span><br><span class="line">2.安装git部署插件： npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<h2 id="2-基本设置"><a href="#2-基本设置" class="headerlink" title="2.基本设置"></a>2.基本设置</h2><ol>
<li>hexo设置参考链接: <a href="https://hexo.io/zh-cn/docs/configuration.html">https://hexo.io/zh-cn/docs/configuration.html</a></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;创建hexo工程</span><br><span class="line">hexo init blog</span><br><span class="line">hexo g			&#x2F;&#x2F;生成静态文件</span><br><span class="line">hexo s 			&#x2F;&#x2F;运行本地服务器</span><br><span class="line">hexo clean		&#x2F;&#x2F;清除缓存</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在站点_config.xml文件中 配置本地hexo上传地址</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:hellohake&#x2F;hellohake.github.io.git</span><br><span class="line">  branch: main</span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F;设置域名解析（CNAME，A，txt字段设置）</span><br><span class="line">hellohake.top 与 hellohake.github.io绑定</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;blog&#x2F;source目录下创建CNAME文件写入域名</span><br><span class="line">hellohake.top</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;站点基本信息配置</span><br><span class="line">title: Hello&#39;s Blog</span><br><span class="line">subtitle: &#39;&#39;</span><br><span class="line">description: 保持好奇</span><br><span class="line">keywords:</span><br><span class="line">author: hellohake</span><br><span class="line">avatar: https:&#x2F;&#x2F;blog.csdn.net&#x2F;hellohake		&#x2F;&#x2F;网站头像外部链接</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone: Asia&#x2F;Shanghai</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;博文打赏微信，支付宝图片，在主题_config.xml文件中配置，将制作好的二维码图片放入themes&#x2F;next&#x2F;source&#x2F;images文件里，并命名为wechatpay.png和alipay.png</span><br><span class="line">wechatpay: &#x2F;images&#x2F;wechatpay.jpg</span><br><span class="line">alipay: &#x2F;images&#x2F;alipay.jpg</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置博客持久化连接</span><br><span class="line">npm install hexo-abbrlink --save	&#x2F;&#x2F;安装</span><br><span class="line">	&#x2F;&#x2F;站点文件配置</span><br><span class="line">	permalink: post&#x2F;:abbrlink.html</span><br><span class="line">    abbrlink:</span><br><span class="line">      alg: crc32  </span><br><span class="line">      rep: hex    </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;添加本地搜索功能 安装到node_modules目录下  本地无法查看</span><br><span class="line">npm install hexo-generator-searchdb --save</span><br><span class="line">  &#x2F;&#x2F;站点配置文件中进行添加</span><br><span class="line">  search:</span><br><span class="line">      path: search.xml</span><br><span class="line">      field: post</span><br><span class="line">      format: html</span><br><span class="line">      limit: 100</span><br><span class="line">  &#x2F;&#x2F;主题配置文件中设置</span><br><span class="line">  local_search:</span><br><span class="line">  	enable: true</span><br></pre></td></tr></table></figure>

<hr>
<p>tips : hexo 写文章创建文件自动打开编辑器 :  编写一段脚本：<a href="https://blog.csdn.net/senupp/article/details/103986447">https://blog.csdn.net/senupp/article/details/103986447</a></p>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210417164929.png" alt="image-20210417164929397"></p>
<h2 id="3-主题美化"><a href="#3-主题美化" class="headerlink" title="3.主题美化"></a>3.主题美化</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;安装next主题（注意从官方clone,不要从第三方clone）</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next.git themes&#x2F;next	&#x2F;&#x2F;helloblog目录下进行</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;站点_config.xml文件中配置主题样式</span><br><span class="line">theme: next</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;主题_config.xml文件中设置主题样式</span><br><span class="line"># Schemes</span><br><span class="line">scheme: Pisces</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Menu增加关于，标签，分类页面</span><br><span class="line">menu:</span><br><span class="line">  home: &#x2F; || fa fa-home</span><br><span class="line">  categories: &#x2F;categories&#x2F; || fa fa-th</span><br><span class="line">  tags: &#x2F;tags&#x2F; || fa fa-tags</span><br><span class="line">  about: &#x2F;about&#x2F; || fa fa-user</span><br><span class="line">	&#x2F;&#x2F;新建相关页面</span><br><span class="line">	hexo new page &quot;about&quot;</span><br><span class="line">	hexo new page &quot;tags&quot;</span><br><span class="line">	hexo new page &quot;categories&quot;</span><br><span class="line">	&#x2F;&#x2F;修改页面文件配置（front matter修改）</span><br><span class="line">	---</span><br><span class="line">    title: 关于</span><br><span class="line">    type: &quot;about&quot;</span><br><span class="line">    ---</span><br><span class="line">    ---</span><br><span class="line">    title: 标签</span><br><span class="line">    type: &quot;tags&quot;</span><br><span class="line">    ---</span><br><span class="line">    ---</span><br><span class="line">    title: 分类</span><br><span class="line">    type: &quot;categories&quot;</span><br><span class="line">    ---</span><br><span class="line">    &#x2F;&#x2F;设置图标，统计信息是否显示</span><br><span class="line">	menu_settings:</span><br><span class="line">  	icons: true   # 显示图标</span><br><span class="line">  	badges: true  # 显示统计信息</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;主题配置文件中，头像设置</span><br><span class="line"># Sidebar Avatar</span><br><span class="line">avatar:</span><br><span class="line">  # Replace the default image and set the url here.</span><br><span class="line">  url: &#x2F;images&#x2F;avatar.png</span><br><span class="line">  # If true, the avatar will be dispalyed in circle.</span><br><span class="line">  rounded: true</span><br><span class="line">  # If true, the avatar will be rotated with the cursor.</span><br><span class="line">  rotated: false</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F;主题配置文件中设置网站图标</span><br><span class="line">favicon:</span><br><span class="line">  small: &#x2F;images&#x2F;h_16.ico</span><br><span class="line">  medium: &#x2F;images&#x2F;h_32.ico</span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F;设置网页代码样式：</span><br><span class="line">codeblock:</span><br><span class="line">  # Code Highlight theme</span><br><span class="line">  # Available values: normal | night | night eighties | night blue | night bright | solarized | solarized dark | galactic</span><br><span class="line">  # See: https:&#x2F;&#x2F;github.com&#x2F;chriskempson&#x2F;tomorrow-theme</span><br><span class="line">  highlight_theme: night eighties</span><br><span class="line">  # Add copy button on codeblock</span><br><span class="line">  copy_button:</span><br><span class="line">    enable: true</span><br><span class="line">    # Show text copy result.</span><br><span class="line">    show_result: true</span><br><span class="line">    # Available values: default | flat | mac</span><br><span class="line">    style: mac</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;页脚配置footer</span><br><span class="line">footer:</span><br><span class="line">  # Specify the date when the site was setup. If not defined, current year will be used.</span><br><span class="line">  since: 2021</span><br><span class="line">  # Powered by Hexo &amp; NexT</span><br><span class="line">  powered: false</span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F;设置左上角或右上角 github 图标</span><br><span class="line">github_banner:</span><br><span class="line">  enable: true</span><br><span class="line">  permalink: https:&#x2F;&#x2F;github.com&#x2F;hellohake</span><br><span class="line">  title: Follow me on GitHub</span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F;使用图标符号代替底部标签</span><br><span class="line">tag_icon: true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置theme-next-three 背景动画（主题目录下）</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-three source&#x2F;lib&#x2F;three</span><br><span class="line">    &#x2F;&#x2F;打开效果</span><br><span class="line">    # three_waves</span><br><span class="line">    three_waves: false</span><br><span class="line">    # canvas_lines</span><br><span class="line">    canvas_lines: true</span><br><span class="line">    # canvas_sphere</span><br><span class="line">    canvas_sphere: false</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;文章末尾显示版权信息</span><br><span class="line"> creative_commons:</span><br><span class="line">  license: by-nc-sa</span><br><span class="line">  sidebar: false</span><br><span class="line">  post: true</span><br><span class="line">  language:</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;图片放大预览</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置tagcloud</span><br><span class="line">npm install hexo-tag-cloud@^2.0.* --save </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;配置gitalk gitalk设置有问题，改用Valine</span><br><span class="line">1. 在github,settings, developer settings 下设置OAuth Apps </span><br><span class="line">未找到相关的 Issues 进行评论 请联系 @hellohake 初始化创建</span><br><span class="line">	&#x2F;&#x2F;Valine评论系统使用说明：</span><br><span class="line">	https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;b9e73c881729</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置打赏</span><br><span class="line">reward_settings:</span><br><span class="line">  # If true, reward will be displayed in every article by default.</span><br><span class="line">  enable: true</span><br><span class="line">  animation: false</span><br><span class="line">  #comment: 打赏</span><br><span class="line"></span><br><span class="line">reward:</span><br><span class="line">  #wechatpay: &#x2F;images&#x2F;wechatpay.jpg</span><br><span class="line">  alipay: &#x2F;images&#x2F;alipay.jpg</span><br><span class="line">  #paypal: &#x2F;images&#x2F;paypal.png</span><br><span class="line">  #bitcoin: &#x2F;images&#x2F;bitcoin.png</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- more --&gt;  &#x2F;&#x2F;设置阅读全文</span><br></pre></td></tr></table></figure>

<h2 id="4-待操作"><a href="#4-待操作" class="headerlink" title="4.待操作"></a>4.待操作</h2><ul>
<li>百度(爬虫屏蔽)，谷歌收录个人博客;</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;orianna-zzo.github.io&#x2F;sci-tech&#x2F;2018-01&#x2F;blog%E5%85%BB%E6%88%90%E8%AE%B05-%E8%A6%81%E8%AE%A9github-pages%E8%A2%AB%E7%B4%A2%E5%BC%95%E5%88%B0&#x2F;</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;duansm.top&#x2F;2018&#x2F;08&#x2F;08&#x2F;hexo-sitemap&#x2F;</span><br></pre></td></tr></table></figure>

<ul>
<li></li>
</ul>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>ETH学习</title>
    <url>/post/3f80cd6e.html</url>
    <content><![CDATA[<h1 id="GTX1660S显卡挖ETH测试"><a href="#GTX1660S显卡挖ETH测试" class="headerlink" title="GTX1660S显卡挖ETH测试"></a>GTX1660S显卡挖ETH测试</h1><p>待操作~</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode_20210412</title>
    <url>/post/7ce22a4f.html</url>
    <content><![CDATA[<h1 id="179-最大数"><a href="#179-最大数" class="headerlink" title="179.最大数"></a>179.最大数</h1><blockquote>
<p>给定一组非负整数 <code>nums</code>，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。</p>
</blockquote>
<hr>
<p><strong>看到2个整数x,y如何拼接得到的结果更大时，先转字符串，然后比较x+y和y+x的大小</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">关键思路：数组转换为字符串进行排序</span><br><span class="line">如果ab拼接比ba好，我们认为a应该放在b的前面（比较器规则）</span><br><span class="line">特殊情况：前导0去除</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Coding</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">largestNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        String[] s = <span class="keyword">new</span> String[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            s[i] = <span class="string">&quot;&quot;</span> + nums[i];</span><br><span class="line">        Arrays.sort(s, (a,b)-&gt;&#123;</span><br><span class="line">            String ab = a + b , ba = b + a;</span><br><span class="line">            <span class="keyword">return</span> ba.compareTo(ab);</span><br><span class="line">        &#125;);</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(String ss : s)</span><br><span class="line">            sb.append(ss);</span><br><span class="line">        <span class="comment">//去除前导0</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(k &lt; n - <span class="number">1</span> &amp;&amp; sb.charAt(k) == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            k++;</span><br><span class="line">        <span class="keyword">return</span> sb.substring(k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="剑指Offer45-把数组排成最小的数"><a href="#剑指Offer45-把数组排成最小的数" class="headerlink" title="剑指Offer45.把数组排成最小的数"></a>剑指Offer45.把数组排成最小的数</h1><blockquote>
<p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p>
</blockquote>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">思路同上</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        String[] ss = <span class="keyword">new</span> String[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            ss[i] = <span class="string">&quot;&quot;</span> + nums[i];</span><br><span class="line">        Arrays.sort(ss, <span class="keyword">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                String s1 = o1 + o2 , s2 = o2 + o1;</span><br><span class="line">                <span class="keyword">return</span> s1.compareTo(s2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(String s : ss)</span><br><span class="line">            sb.append(s);</span><br><span class="line">        <span class="comment">//题目说不用去前导0</span></span><br><span class="line">        <span class="comment">// int k = 0;</span></span><br><span class="line">        <span class="comment">// while(k &lt; n - 1 &amp;&amp; sb.charAt(k) == &#x27;0&#x27;)</span></span><br><span class="line">        <span class="comment">//     k++;</span></span><br><span class="line">        <span class="comment">// return sb.substring(k);</span></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">思路2：使用小根堆，将字典序小的放在堆顶（O1 + O2 &gt; O2 + O1)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Coding</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1 , String o2)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="comment">//字典序小的放在栈顶</span></span><br><span class="line">                <span class="keyword">return</span> (o1 + o2).compareTo(o2 + o1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)</span><br><span class="line">            queue.add(<span class="string">&quot;&quot;</span> + num);</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())</span><br><span class="line">            sb.append(queue.poll());</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode_20210413</title>
    <url>/post/e1edcb39.html</url>
    <content><![CDATA[<h1 id="783-二叉搜索树节点的最小距离"><a href="#783-二叉搜索树节点的最小距离" class="headerlink" title="783. 二叉搜索树节点的最小距离"></a>783. 二叉搜索树节点的最小距离</h1><blockquote>
<p>给你一个二叉搜索树的根节点 <code>root</code> ，返回 <strong>树中任意两不同节点值之间的最小差值</strong> 。</p>
</blockquote>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">思路： 考察二叉搜索树中序遍历有序的特点，两不同节点值之间的最小差值一定在相邻两元素之间</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//迭代实现（模拟栈）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDiffInBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">//中序遍历</span></span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span> || !stack.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(root != <span class="keyword">null</span>)</span><br><span class="line">            &#123;               </span><br><span class="line">                stack.addLast(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pollLast();</span><br><span class="line">            <span class="keyword">if</span>(pre != <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                min = Math.min(min , root.val - pre.val);</span><br><span class="line">            &#125;</span><br><span class="line">            pre = root;         <span class="comment">//保存前一个结点</span></span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDiffInBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            min = Math.min(root.val - pre.val , min);</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root;     <span class="comment">//更新pre为前一个结点</span></span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode_20210417</title>
    <url>/post/6a766917.html</url>
    <content><![CDATA[<h1 id="220-存在重复元素III"><a href="#220-存在重复元素III" class="headerlink" title="220.存在重复元素III"></a>220.存在重复元素III</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给你一个整数数组 nums 和两个整数 k 和 t 。请你判断是否存在 两个不同下标 i 和 j，使得 abs(nums[i] - nums[j]) &lt;&#x3D; t ，同时又满足 abs(i - j) &lt;&#x3D; k 。</span><br><span class="line"></span><br><span class="line">如果存在则返回 true，不存在返回 false。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路： 滑动窗口 + 双指针，<code>TreeSet</code>的使用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        TreeSet&lt;Long&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">long</span> u = nums[i];</span><br><span class="line">            Long min = set.floor(u);    <span class="comment">//找到小于等于u的最接近u的数</span></span><br><span class="line">            Long max = set.ceiling(u);  <span class="comment">//找到大于等于u的最小值</span></span><br><span class="line">            <span class="keyword">if</span>(min != <span class="keyword">null</span> &amp;&amp; u - min &lt;= t)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(max != <span class="keyword">null</span> &amp;&amp; max - u &lt;= t)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//维护窗口大小k</span></span><br><span class="line">            set.add(u);</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k)</span><br><span class="line">                set.remove(nums[i-k] * <span class="number">1L</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路2：桶排序</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode_20210414</title>
    <url>/post/28aa04ef.html</url>
    <content><![CDATA[<h1 id="208-实现Trie-前缀树"><a href="#208-实现Trie-前缀树" class="headerlink" title="208.实现Trie(前缀树)"></a>208.实现Trie(前缀树)</h1><p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210414093343.png" alt="image-20210414093343520"></p>
<hr>
<blockquote>
<p>思路：<strong>前缀树</strong>是一颗<strong>非典型的多叉树模型</strong>：<strong>前缀树不存储具体的字符值，使用字符映射表将具体的值映射为数组下标</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//多叉树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">ValueType value;</span><br><span class="line">TreeNode children = <span class="keyword">new</span> TreeNode[num];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前缀树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span></span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> isLeaf;		<span class="comment">//是否是叶子结点</span></span><br><span class="line">TrieNode children = <span class="keyword">new</span> TrieNode[num];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//coding</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Trie[] node;</span><br><span class="line">    <span class="keyword">boolean</span> isLeaf;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        node = <span class="keyword">new</span> Trie[<span class="number">26</span>];</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        Trie t = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(t.node[word.charAt(i) - <span class="string">&#x27;a&#x27;</span>] == <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                t.node[word.charAt(i) - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> Trie();</span><br><span class="line">            &#125;</span><br><span class="line">            t = t.node[word.charAt(i) - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        t.isLeaf = <span class="keyword">true</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        Trie t = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(t.node[word.charAt(i) - <span class="string">&#x27;a&#x27;</span>] == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                t = t.node[word.charAt(i) - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t.isLeaf;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        Trie t = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(t.node[prefix.charAt(i) - <span class="string">&#x27;a&#x27;</span>] == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                t = t.node[prefix.charAt(i) - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>N皇后</title>
    <url>/post/bd497d25.html</url>
    <content><![CDATA[<h1 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h1><ul>
<li>LeetCode 51题：</li>
</ul>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210413162600.png" alt="image-20210413162559960"></p>
<hr>
<blockquote>
<p>思路：回溯暴力搜索，棋盘格对应位置是否可填充皇后取决于其左上、左下、右上、右下是否含有皇后（<strong>判断条件</strong>）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Coding</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt;  res  =  <span class="keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[][]  chess = <span class="keyword">new</span> <span class="keyword">char</span>[n][n];</span><br><span class="line">        <span class="comment">//填充初始棋盘</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                chess[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        dfs(<span class="number">0</span> , res , chess);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> row , List&lt;List&lt;String&gt;&gt;  res  ,   <span class="keyword">char</span>[][] chess)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row == chess.length)</span><br><span class="line">        &#123;</span><br><span class="line">            res.add(copy(chess));           <span class="comment">//深拷贝</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//做选择</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>;  col &lt; chess[<span class="number">0</span>].length;  col++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(isVaild(chess , row , col))</span><br><span class="line">            &#123;</span><br><span class="line">                chess[row][col] = <span class="string">&#x27;Q&#x27;</span>;  <span class="comment">//选择</span></span><br><span class="line">                dfs(row + <span class="number">1</span> , res , chess);             <span class="comment">//递归</span></span><br><span class="line">                chess[row][col] = <span class="string">&#x27;.&#x27;</span>;  <span class="comment">//回溯</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">copy</span><span class="params">(<span class="keyword">char</span>[][] chess)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;String&gt;  ret = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chess.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            StringBuilder tmp = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; chess[<span class="number">0</span>].length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp.append(chess[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            ret.add(tmp.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isVaild</span><span class="params">(<span class="keyword">char</span>[][] chess,  <span class="keyword">int</span> row , <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> n = chess.length;</span><br><span class="line">        <span class="comment">//(row , col)上方列是否包含Q</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(chess[i][col] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//(row , col)左上方判断</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = row - <span class="number">1</span> , j = col - <span class="number">1</span>;  i  &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span> ; i-- , j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(chess[i][j] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//(row, col)右上方判断</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>  i = row - <span class="number">1</span> ,  j = col + <span class="number">1</span>;  i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i-- , j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(chess[i][j] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>背包</title>
    <url>/post/bfd1492e.html</url>
    <content><![CDATA[<h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><p>Mark一下力扣上背包各种类型题目;</p>
<h2 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h2><h3 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416-分割等和子集"></a>416-分割等和子集</h3><blockquote>
<p>给定一个<strong>只包含正整数</strong>的<strong>非空</strong>数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
</blockquote>
<blockquote>
<p>问题转换： 先对集合求和sum,</p>
<p>给一个可装载重量为sum/2 的背包和N个物品，每个物品重量为nums[i] , 能否存在一种装法，将背包恰好装满；</p>
<p>dp数组定义:   dp[i][j] :   背包容量为j ,   前i个物品能否将该背包装满；</p>
<p>状态转移方程：  dp[i][j]  =   dp[i-1][j] || dp[i-1][j - nums[i-1]](j - nums[i-1] &gt; = 0)    //可以选择装还是不装该物品；</p>
<p>dp[i][j] = dp[i-1][j]   (j - nums[i-1] &lt; 0)</p>
<p>base case :  dp[0][..]  = false;   dp[..][0]  = true;</p>
<p>填表方向：从左到右，从上到下</p>
<p>状态压缩：使用滚动数组对dp数组进行优化</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C++</span></span><br><span class="line"><span class="function">bool <span class="title">canPartition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) sum += num;</span><br><span class="line">    <span class="comment">// 和为奇数时，不可能划分成两个和相等的集合</span></span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    sum = sum / <span class="number">2</span>;</span><br><span class="line">    vector&lt;vector&lt;bool&gt;&gt; </span><br><span class="line">        dp(n + <span class="number">1</span>, vector&lt;bool&gt;(sum + <span class="number">1</span>, <span class="keyword">false</span>));</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= sum; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j - nums[i - <span class="number">1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">// 背包容量不足，不能装入第 i 个物品</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j]; </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 装入或不装入背包</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] || dp[i - <span class="number">1</span>][j-nums[i-<span class="number">1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>状态压缩：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> e : nums)</span><br><span class="line">            sum += e;</span><br><span class="line">        <span class="keyword">if</span>(sum % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        sum /= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[sum+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = sum; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j - nums[i-<span class="number">1</span>] &gt;= <span class="number">0</span>)</span><br><span class="line">                    dp[j] = dp[j] || dp[j - nums[i-<span class="number">1</span>]];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[j] = dp[j];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[sum];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322.零钱兑换"></a>322.零钱兑换</h3><blockquote>
<p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
</blockquote>
<hr>
<hr>
<blockquote>
<p>完全背包：dp[j] = min(dp[j - coin[i]] + 1)</p>
<p>dp数组求最大值则初始化最小值，求最小值则初始化最大值</p>
<p>参考：<a href="https://mp.weixin.qq.com/s/dyk-xNilHzNtVdPPLObSeQ">https://mp.weixin.qq.com/s/dyk-xNilHzNtVdPPLObSeQ</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(amount == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class="line">        <span class="comment">//边界</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//排列数，组合数不重要（这题）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coins.length; i++)   <span class="comment">//外层物品（组合数）</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = coins[i]; j &lt;= amount; j++)    <span class="comment">//完全背包，正序遍历</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j - coins[i]] != Integer.MAX_VALUE)   <span class="comment">//有意义的值才计算</span></span><br><span class="line">                    dp[j] = Math.min(dp[j] , dp[j - coins[i]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[amount] == Integer.MAX_VALUE)     <span class="comment">//无法凑出</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="377-组合总和IV"><a href="#377-组合总和IV" class="headerlink" title="377.组合总和IV"></a>377.组合总和IV</h3><blockquote>
<p>给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。</p>
<p>题目数据保证答案符合 32 位整数范围。</p>
</blockquote>
<hr>
<hr>
<blockquote>
<p>背包问题，求<strong>排列数</strong>；</p>
<p><strong>外层背包，内层物品</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//base</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;      <span class="comment">//该元素赋值无意义，仅用于计算</span></span><br><span class="line">        <span class="comment">//背包排列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= target; i++)        <span class="comment">//外层背包</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++)    <span class="comment">//内层物品</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt;= nums[j])</span><br><span class="line">                    dp[i] += dp[i - nums[j]];   <span class="comment">//防止溢出</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="518-零钱兑换-II"><a href="#518-零钱兑换-II" class="headerlink" title="518.零钱兑换 II"></a>518.<a href="https://leetcode-cn.com/problems/coin-change-2/">零钱兑换 II</a></h3><blockquote>
<p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 </p>
</blockquote>
<hr>
<hr>
<blockquote>
<p>求组合数：外层遍历物品，内层遍历背包</p>
<p>求排列数：外层遍历背包，内层遍历物品</p>
<p>组合数状态转移方程：dp[i] += dp[i-coin[j]];</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//求组合数</span></span><br><span class="line">        <span class="keyword">if</span>(amount == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] =<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//求组合数，外层遍历物品，里层遍历背包</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coins.length; i++)       <span class="comment">//遍历物品</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = coins[i]; j &lt;= amount; j++) <span class="comment">//遍历背包</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[j] += dp[j - coins[i]];      <span class="comment">//状态转移方程</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494.目标和"></a>494.目标和</h3><blockquote>
<p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。</p>
<p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p>
</blockquote>
<hr>
<hr>
<blockquote>
<p>参考：<a href="https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&amp;mid=2247486709&amp;idx=1&amp;sn=75f1f43d96dbd1c5c3e281b8963e3c50&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&amp;mid=2247486709&amp;idx=1&amp;sn=75f1f43d96dbd1c5c3e281b8963e3c50&amp;scene=21#wechat_redirect</a></p>
<p>A - B = S;</p>
<p>A + B = sum；</p>
<p>A = (S + sum) / 2;</p>
<p><strong>求数组中和为A的组合数</strong></p>
<p>一维dp遍历时，内层循环倒数遍历，保证物品i只放入1次</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> e : nums)</span><br><span class="line">            sum += e;</span><br><span class="line">        <span class="keyword">if</span>(S &gt; sum)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(((sum + S) % <span class="number">2</span>) == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> T = (sum + S) / <span class="number">2</span>;      <span class="comment">//求装满背包T的组合数</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[T+<span class="number">1</span>];    </span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)    <span class="comment">//外层物品</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = T; j &gt;= nums[i]; j--)    <span class="comment">//内层背包,倒序遍历保证每个物品只添加一次（01背包，不是完全背包）</span></span><br><span class="line">                dp[j] += dp[j - nums[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[T];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode_20210418</title>
    <url>/post/fac97486.html</url>
    <content><![CDATA[<h1 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26.删除有序数组中的重复项"></a>26.删除有序数组中的重复项</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。</span><br><span class="line"></span><br><span class="line">不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路：双指针i , j ，，，指针i指向已删除后不带重复项的元素，指针j指向原数组</p>
<p>比较i, j 对应位置是否相等</p>
<p>如果相等，j后移一位</p>
<p>如果不等，将j位置元素复制到i + 1处，i++，</p>
<p>新数组长度： i + 1</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>( ; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] == nums[i])</span><br><span class="line">            &#123;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums[++i] = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//写法2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span> , j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != nums[j])</span><br><span class="line">            &#123;</span><br><span class="line">                nums[++i] = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>lc-438</title>
    <url>/post/bd35841e.html</url>
    <content><![CDATA[<h1 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a>438. <a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">找到字符串中所有字母异位词</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。</span><br><span class="line"></span><br><span class="line">字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line">字母异位词指字母相同，但排列不同的字符串。</span><br><span class="line">不考虑答案输出的顺序。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路1：滑动窗口 + 数组 + Arrays.equals()方法使用</p>
<p>首先建立一个大小为m的窗口，然后进行滑窗，每次滑动后比较2出现次数数组是否相等，相等则添加对应数组下标</p>
<p>时间复杂度：O(n)   空间复杂度： O(1)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length() , m = p.length();</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(n &lt; m)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span>[] pCnt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span>[] sCnt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            pCnt[p.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            sCnt[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Arrays.equals(sCnt , pCnt))</span><br><span class="line">            res.add(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = m ; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sCnt[s.charAt(i - m) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            sCnt[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            <span class="keyword">if</span>(Arrays.equals(sCnt , pCnt))</span><br><span class="line">                res.add(i - m + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路2： 使用滑动窗口 + 双指针，使用双指针表示滑动窗口的左右边界，当滑动窗口长度为p的长度时，保是找到一个异位词</p>
<p>注意Coding</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length() , m = p.length();</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(n &lt; m)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span>[] pCnt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span>[] sCnt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="comment">//统计字符出现次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            pCnt[p.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(; right &lt; n; right++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> curRight = s.charAt(right) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            sCnt[curRight]++;</span><br><span class="line">            <span class="keyword">while</span>(sCnt[curRight] &gt; pCnt[curRight])  <span class="comment">//最坏情况，left 与right 重合</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> curLeft = s.charAt(left) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                sCnt[curLeft]--;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(right - left + <span class="number">1</span> == m)   <span class="comment">//滑动窗口大小为m时，符合条件，添加数组元素对应下标</span></span><br><span class="line">                res.add(left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>热题100道</category>
      </categories>
      <tags>
        <tag>热题100道</tag>
      </tags>
  </entry>
  <entry>
    <title>lc_20210419</title>
    <url>/post/561b7852.html</url>
    <content><![CDATA[<h1 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27.移除元素"></a>27.移除元素</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</span><br><span class="line"></span><br><span class="line">不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</span><br><span class="line"></span><br><span class="line">元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路：使用双指针，左指针指向下一个将要赋值的位置，右指针指向当前要处理的元素；</p>
<p>画图分析返回数据的长度是 i  还是 i + 1;</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] != val)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>第一种方法缺点，如果要删除的元素位于数组开头，大部分元素都需要移动，时间复杂度比较高，可以设置分别指向左右边界的指针，进行交换，<strong>数组中元素顺序可以改变！！</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span> , right = n;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left] == val)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[left] = nums[right - <span class="number">1</span>];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>lc-621</title>
    <url>/post/de76d995.html</url>
    <content><![CDATA[<h1 id="621-任务调度器"><a href="#621-任务调度器" class="headerlink" title="621. 任务调度器"></a><a href="https://leetcode-cn.com/problems/task-scheduler/">621. 任务调度器</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给你一个用字符数组 tasks 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。</span><br><span class="line"></span><br><span class="line">然而，两个 相同种类 的任务之间必须有长度为整数 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。</span><br><span class="line"></span><br><span class="line">你需要计算完成所有任务所需要的 最短时间 。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路：桶思想，完成所有任务的最短时间取决于出现次数最多的任务数量；</p>
<p>贪心思想：优先安排出现次数最多的任务，让该任务两次执行的时间恰好为n，在这个时间间隔内填充其他任务；</p>
<p>计算公式：max( 并行最大任务数 +  （并行最大次数 - 1） * （ n + 1）(n为冷却时间)  ,   任务数组长度);</p>
<p>情况1：</p>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210419152356.png" alt="image-20210419152356496"></p>
<p>情况2：</p>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210419152404.png" alt="image-20210419152404886"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//coding1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(<span class="keyword">char</span>[] tasks, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//统计各任务出现次数</span></span><br><span class="line">        <span class="keyword">int</span> t = tasks.length;</span><br><span class="line">        <span class="keyword">int</span>[] taskCnt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; i++)</span><br><span class="line">            taskCnt[tasks[i] - <span class="string">&#x27;A&#x27;</span>]++;</span><br><span class="line">        Arrays.sort(taskCnt);   <span class="comment">//具体是哪个任务最多出现次数不重要</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;            <span class="comment">//最大并行任务数统计</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">25</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(taskCnt[i] == taskCnt[<span class="number">25</span>])</span><br><span class="line">                cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(t , cnt + (taskCnt[<span class="number">25</span>] - <span class="number">1</span>) * (n + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>热题100道</category>
      </categories>
      <tags>
        <tag>热题100道</tag>
      </tags>
  </entry>
  <entry>
    <title>lc-581</title>
    <url>/post/26df8f46.html</url>
    <content><![CDATA[<h1 id="581-最短无序连续子数组"><a href="#581-最短无序连续子数组" class="headerlink" title="581.最短无序连续子数组"></a>581.<a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/">最短无序连续子数组</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给你一个整数数组 nums ，你需要找出一个 连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</span><br><span class="line">请你找出符合题意的 最短 子数组，并输出它的长度。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路1 ： 首先进行排序，然后比较左边界和右边界第一个不同的位置</p>
<p>时间复杂度： O(nlogn)</p>
<p>空间复杂度： O(n)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] cnum = nums.clone();</span><br><span class="line">        Arrays.sort(cnum);</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span> , right = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnum[i] != nums[i])</span><br><span class="line">            &#123;</span><br><span class="line">                left = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnum[i] != nums[i])</span><br><span class="line">            &#123;</span><br><span class="line">                right = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right - left == n ? <span class="number">0</span> : right - left + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//写法2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] cnum = nums.clone();</span><br><span class="line">        Arrays.sort(cnum);</span><br><span class="line">        <span class="keyword">int</span> left = n , right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnum[i] != nums[i])</span><br><span class="line">            &#123;</span><br><span class="line">                left = Math.min(left, i);</span><br><span class="line">                right = Math.max(right , i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> right - left &lt; <span class="number">0</span> ? <span class="number">0</span> : right - left + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路2：选择排序，找到无序子数组中最小元素和最大元素分别对应的正确位置，来确定无序子数组的边界</p>
<p>使用栈，时间复杂度：O(n)  空间复杂度： O(n)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> left = n , right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; nums[stack.peek()] &gt; nums[i])</span><br><span class="line">                left = Math.min(left , stack.poll());</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        stack.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; nums[stack.peek()] &lt; nums[i])</span><br><span class="line">                right = Math.max(right , stack.poll());</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right - left &gt; <span class="number">0</span> ? right - left + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>暴力方法</p>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210419144917.png" alt="image-20210419144917134"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> left = n - <span class="number">1</span> , right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n -<span class="number">1</span>; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &lt; nums[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    right = Math.max(right , j);</span><br><span class="line">                    left = Math.min(left , i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> right - left &gt; <span class="number">0</span> ? right - left + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>热题100道</category>
      </categories>
      <tags>
        <tag>热题100道</tag>
      </tags>
  </entry>
  <entry>
    <title>lc-253</title>
    <url>/post/783086a2.html</url>
    <content><![CDATA[<h1 id="253-会议室II"><a href="#253-会议室II" class="headerlink" title="253. 会议室II"></a>253. 会议室II</h1><blockquote>
<p>给定一个会议时间安排的数组，每个会议时间都会包括开始和结束的时间 [[s1,e1],[s2,e2],…] (si &lt; ei)，为避免会议冲突，同时要考虑充分利用会议室资源，请你计算至少需要多少间会议室，才能满足这些会议安排。</p>
<p>示例 1:</p>
<p>输入: [[0, 30],[5, 10],[15, 20]]<br>输出: 2<br>示例 2:</p>
<p>输入: [[7,10],[2,4]]<br>输出: 1</p>
</blockquote>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">热题100道最后一道会员题，哈哈，总算刷完基础100道了~</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路：使用最小堆+数组排序</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMeetingRooms</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; allocator = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(intervals.length , (a , b) -&gt; a- b);</span><br><span class="line">        <span class="comment">//对时间表按照开始时间从小到大排序</span></span><br><span class="line">        Arrays.sort(intervals , (a ,b) -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//添加第一场会议</span></span><br><span class="line">        allocator.add(intervals[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//遍历除第一场会议之外的所有会议</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &gt;= allocator.peek())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//如果当前会议的开始时间大于前面已经开始的会议中最晚结束的时间,则该会议室可以重复使用</span></span><br><span class="line">                allocator.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//把当前会议结束时间加入最小堆中</span></span><br><span class="line">            allocator.add(intervals[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当所有会议遍历完毕，还在最小堆里面的，说明会议还没结束，此时的数量就是会议室的最少数量</span></span><br><span class="line">        <span class="keyword">return</span> allocator.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>热题100道</category>
      </categories>
      <tags>
        <tag>热题100道</tag>
      </tags>
  </entry>
  <entry>
    <title>jzOffer-68-II</title>
    <url>/post/1e8bcec9.html</url>
    <content><![CDATA[<h1 id="剑指-Offer-68-II-二叉树的最近公共祖先"><a href="#剑指-Offer-68-II-二叉树的最近公共祖先" class="headerlink" title="剑指 Offer 68 - II. 二叉树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - II. 二叉树的最近公共祖先</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</span><br><span class="line"></span><br><span class="line">百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</span><br><span class="line"></span><br><span class="line">例如，给定如下二叉树:  root &#x3D; [3,5,1,6,2,0,8,null,null,7,4]</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路：递归，后序遍历，从底向上进行搜索；</p>
<p>公共祖先有3种分布情况：</p>
<ol>
<li>p和 q在 root的子树中，且分列 root的 <strong>异侧</strong>；    2. <em>p</em>=root , q在ro<strong>o</strong>t 的左或右子树中；    3. <em>q</em>=<em>r<strong>o</strong>o**t</em> ，且 p<em>p</em> 在 root<em>r<strong>o</strong>o**t</em> 的左或右子树中；</li>
</ol>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210420102139.png" alt="image-20210420102138999"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || root == p || root == q)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">//后序遍历，从底向上进行搜索</span></span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left , p , q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right , p , q);</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span>(right == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="剑指-Offer-68-I-二叉搜索树的最近公共祖先"><a href="#剑指-Offer-68-I-二叉搜索树的最近公共祖先" class="headerlink" title="剑指 Offer 68 - I. 二叉搜索树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</span><br><span class="line"></span><br><span class="line">百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路：利用二叉搜索树有序的特点</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.val &gt; root.val &amp;&amp; q.val &gt; root.val)</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.right , p ,q);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p.val &lt; root.val &amp;&amp; q.val &lt; root.val)</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.left , p ,q);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//迭代写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        TreeNode res = root;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(res.val &gt; p.val &amp;&amp; res.val &gt; q.val)</span><br><span class="line">            &#123;</span><br><span class="line">                res = res.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(res.val &lt; p.val &amp;&amp; res.val &lt; q.val)</span><br><span class="line">            &#123;</span><br><span class="line">                res = res.right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>lc-28</title>
    <url>/post/46940ce0.html</url>
    <content><![CDATA[<h1 id="28-实现strStr"><a href="#28-实现strStr" class="headerlink" title="28.实现strStr()"></a>28.实现strStr()</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">实现 strStr() 函数。</span><br><span class="line">给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。</span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line">当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</span><br><span class="line">对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>KMP算法：考虑怎么计算next数组，部分匹配表；背模板</p>
<p>复杂度分析：原串长度n，模式串长度m，时间复杂度O(n + m) , 空间复杂度O(m)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = haystack.length() , m = needle.length();</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        haystack = <span class="string">&quot; &quot;</span> + haystack;</span><br><span class="line">        needle = <span class="string">&quot; &quot;</span> + needle;</span><br><span class="line">        <span class="keyword">char</span>[] s = haystack.toCharArray() , p = needle.toCharArray();</span><br><span class="line">        <span class="comment">//计算next数组</span></span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> , j = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; p[i] != p[j+<span class="number">1</span>])  <span class="comment">//匹配不成功，进行回溯</span></span><br><span class="line">                j = next[j];</span><br><span class="line">            <span class="keyword">if</span>(p[j+<span class="number">1</span>] == p[i])      <span class="comment">//匹配成功</span></span><br><span class="line">                j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//原串和模式串匹配</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> , j = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != p[j+<span class="number">1</span>])</span><br><span class="line">                j = next[j];</span><br><span class="line">            <span class="keyword">if</span>(s[i] == p[j+<span class="number">1</span>])</span><br><span class="line">                j++;</span><br><span class="line">            <span class="keyword">if</span>(j == m)</span><br><span class="line">                <span class="keyword">return</span> i - m;   <span class="comment">//整段匹配成功，返回下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路2：  暴力计算，</p>
<p>时间复杂度：原串n , 模式串m ,   O((n - m) * m)</p>
<p>空间复杂度： O(1)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = haystack.length() , m = needle.length();</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>[] s = haystack.toCharArray() , p = needle.toCharArray();</span><br><span class="line">        <span class="comment">//暴力匹配</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - m; i++)		<span class="comment">//注意这里带=号</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k = i , j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; m &amp;&amp; s[k] == p[j])</span><br><span class="line">            &#123;</span><br><span class="line">                k++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j == m)  <span class="comment">//完全匹配</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>jc32-III</title>
    <url>/post/c4f06753.html</url>
    <content><![CDATA[<h1 id="剑指-Offer-32-III-从上到下打印二叉树-III"><a href="#剑指-Offer-32-III-从上到下打印二叉树-III" class="headerlink" title="剑指 Offer 32 - III. 从上到下打印二叉树 III"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">剑指 Offer 32 - III. 从上到下打印二叉树 III</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路：BFS ，层序遍历</p>
<p>奇数层添加到tmp的头部</p>
<p>偶数层添加到tmp的尾部</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Deque&lt;TreeNode&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        queue.addLast(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();     </span><br><span class="line">            LinkedList&lt;Integer&gt; tmp = <span class="keyword">new</span> LinkedList&lt;&gt;();  </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode node = queue.pollFirst();</span><br><span class="line">                <span class="keyword">if</span>(res.size() % <span class="number">2</span> == <span class="number">0</span>)     <span class="comment">//偶数层，队列头部</span></span><br><span class="line">                    tmp.addLast(node.val);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    tmp.addFirst(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)</span><br><span class="line">                    queue.addLast(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)</span><br><span class="line">                    queue.addLast(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>一次打印2层</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Deque&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.addLast(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            LinkedList&lt;Integer&gt; tmp = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)       <span class="comment">//奇数层</span></span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode node = queue.pollFirst();</span><br><span class="line">                tmp.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)</span><br><span class="line">                    queue.addLast(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)</span><br><span class="line">                    queue.addLast(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">            tmp = <span class="keyword">new</span> LinkedList&lt;&gt;();            <span class="comment">//清空</span></span><br><span class="line">            size = queue.size();    <span class="comment">//偶数层</span></span><br><span class="line">            <span class="keyword">if</span>(size == <span class="number">0</span>)           <span class="comment">//偶数层没有，直接跳出</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)       <span class="comment">//奇数层</span></span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode node = queue.pollLast();   <span class="comment">//从右向左打印</span></span><br><span class="line">                tmp.addLast(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)</span><br><span class="line">                    queue.addFirst(node.right);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)</span><br><span class="line">                    queue.addFirst(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>jz-33</title>
    <url>/post/6a0c099c.html</url>
    <content><![CDATA[<h1 id="剑指-Offer-33-二叉搜索树的后序遍历序列"><a href="#剑指-Offer-33-二叉搜索树的后序遍历序列" class="headerlink" title="剑指 Offer 33. 二叉搜索树的后序遍历序列"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">剑指 Offer 33. 二叉搜索树的后序遍历序列</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210421171510.png" alt="image-20210421171510668"></p>
<hr>
<blockquote>
<p>递归：</p>
<p>1 3 2[左子树]   6[右子树]   5[根]</p>
<p>–&gt;二叉搜索树特性：左子树区间所有元素都小于根结点，右子树区间所有元素都大于根节点元素</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyPostorder</span><span class="params">(<span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertify(postorder, <span class="number">0</span> , postorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">vertify</span><span class="params">(<span class="keyword">int</span>[] postorder , <span class="keyword">int</span> i , <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= j)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> p = i;</span><br><span class="line">        <span class="keyword">while</span>(postorder[p] &lt; postorder[j])</span><br><span class="line">            p++;</span><br><span class="line">        <span class="keyword">int</span> m = p;</span><br><span class="line">        <span class="keyword">while</span>(postorder[p] &gt; postorder[j])</span><br><span class="line">            p++;</span><br><span class="line">        <span class="keyword">return</span> p == j &amp;&amp; vertify(postorder , i , m - <span class="number">1</span>) &amp;&amp; vertify(postorder , m, j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>辅助栈：</p>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210421172404.png" alt="image-20210421172404626"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyPostorder</span><span class="params">(<span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> root = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = postorder.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(postorder[i] &gt; root) </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peekLast() &gt; postorder[i])</span><br><span class="line">                root = stack.pollLast();</span><br><span class="line">            stack.addLast(postorder[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>美团暑期实习算法题</title>
    <url>/post/b9706eda.html</url>
    <content><![CDATA[<h1 id="39-组合总数（力扣）"><a href="#39-组合总数（力扣）" class="headerlink" title="39.组合总数（力扣）"></a>39.组合总数（力扣）</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</span><br><span class="line"></span><br><span class="line">candidates 中的数字可以无限制重复被选取。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>回溯，暴力搜索 + 部分剪枝，面试前一个月做的，然后具体细节有些忘了，然后run了爆栈。。。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(candidates.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        dfs(<span class="number">0</span> , candidates , target , <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> idx , <span class="keyword">int</span>[] candidates , <span class="keyword">int</span> target , <span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(idx == candidates.length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum == target)</span><br><span class="line">        &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tmp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; target)    <span class="comment">//剪枝</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//不选择当前元素</span></span><br><span class="line">        dfs(idx + <span class="number">1</span> , candidates, target ,sum);</span><br><span class="line">        <span class="comment">//选择</span></span><br><span class="line">        tmp.add(candidates[idx]);</span><br><span class="line">        dfs(idx, candidates , target , sum + candidates[idx]);  <span class="comment">//下一步递归仍然可能选择该元素</span></span><br><span class="line">        tmp.remove(tmp.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>写法2：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(candidates.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        dfs(<span class="number">0</span> , candidates , target , <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> idx , <span class="keyword">int</span>[] candidates , <span class="keyword">int</span> target , <span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(idx == candidates.length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum == target)</span><br><span class="line">        &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tmp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = idx ; i &lt; candidates.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(sum + candidates[i] &lt;= target)   <span class="comment">//剪枝</span></span><br><span class="line">            &#123;</span><br><span class="line">                tmp.add(candidates[i]);</span><br><span class="line">                dfs(i , candidates , target , sum + candidates[i]);</span><br><span class="line">                tmp.remove(tmp.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="40-组合总数II-力扣"><a href="#40-组合总数II-力扣" class="headerlink" title="40.组合总数II(力扣)"></a>40.组合总数II(力扣)</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</span><br><span class="line"></span><br><span class="line">candidates 中的每个数字在每个组合中只能使用一次。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>这里需要去重，回溯 + 剪枝 + 去重</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = candidates.length;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        dfs(<span class="number">0</span> , candidates , target , <span class="number">0</span> , res , tmp);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> idx , <span class="keyword">int</span>[] candidates , <span class="keyword">int</span> target , <span class="keyword">int</span> sum , List&lt;List&lt;Integer&gt;&gt; res , List&lt;Integer&gt; tmp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == target)</span><br><span class="line">        &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tmp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = idx ; i &lt; candidates.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(sum + candidates[i] &gt; target)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; idx &amp;&amp; candidates[i] == candidates[i-<span class="number">1</span>])  <span class="comment">//下一个元素相同直接跳过</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            tmp.add(candidates[i]);                </span><br><span class="line">            dfs(i + <span class="number">1</span>, candidates , target , sum + candidates[i] , res , tmp);  <span class="comment">//不可选择重复元素</span></span><br><span class="line">            tmp.remove(tmp.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>























]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>lc-91</title>
    <url>/post/dcbc6d8f.html</url>
    <content><![CDATA[<h1 id="91-解码方法"><a href="#91-解码方法" class="headerlink" title="91. 解码方法"></a><a href="https://leetcode-cn.com/problems/decode-ways/">91. 解码方法</a></h1><p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210421145236.png" alt="image-20210421145236136"></p>
<hr>
<blockquote>
<p>思路：dp动态规划</p>
<p>dp[i] :  以i结尾的字符串解码方法总数</p>
<p>状态转移方程：</p>
<p>dp[i] = dp[i-1] (s[i-1] != ‘0’)</p>
<p>dp[i] = dp[i-2] (s[i-2] != ‘0’ &amp;&amp; 10 * (s[i-2] - ‘0’) + s[i-1] - ‘0’ &lt;= 26)</p>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210421150139.png" alt="image-20210421150139163"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//边界</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i - <span class="number">1</span>) != <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] += dp[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">1</span> &amp;&amp; s.charAt(i - <span class="number">2</span>) != <span class="string">&#x27;0&#x27;</span> &amp;&amp; (<span class="number">10</span> * (s.charAt(i-<span class="number">2</span>) - <span class="string">&#x27;0&#x27;</span>) + s.charAt(i - <span class="number">1</span>) - <span class="string">&#x27;0&#x27;</span>) &lt;= <span class="number">26</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] += dp[i-<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>jz-55-II</title>
    <url>/post/67391d39.html</url>
    <content><![CDATA[<h1 id="剑指-Offer-55-II-平衡二叉树"><a href="#剑指-Offer-55-II-平衡二叉树" class="headerlink" title="剑指 Offer 55 - II. 平衡二叉树"></a><a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/">剑指 Offer 55 - II. 平衡二叉树</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路：递归计算左右子树的深度，判断其深度相差是否超过1</p>
<p>后续遍历 + 剪枝，从二叉树底部开始向上进行遍历</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> depth(root) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = depth(root.left);</span><br><span class="line">        <span class="keyword">if</span>(left == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = depth(root.right);</span><br><span class="line">        <span class="keyword">if</span>(right == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(right - left) &lt; <span class="number">2</span> ? Math.max(right , left) + <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>写法2：计算深度，先序遍历，存在大量重复计算</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(depth(root.left) - depth(root.right)) &lt; <span class="number">2</span> &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = depth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = depth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left , right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>lc-363</title>
    <url>/post/52dfbf56.html</url>
    <content><![CDATA[<h1 id="363-矩形区域不超过-K-的最大数值和"><a href="#363-矩形区域不超过-K-的最大数值和" class="headerlink" title="363.矩形区域不超过 K 的最大数值和"></a>363.<a href="https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/">矩形区域不超过 K 的最大数值和</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给你一个 m x n 的矩阵 matrix 和一个整数 k ，找出并返回矩阵内部矩形区域的不超过 k 的最大数值和。</span><br><span class="line"></span><br><span class="line">题目数据保证总会存在一个数值和不超过 k 的矩形区域。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路：暴力解决，进行整改二维数组的搜索，使用前缀和 + 二分进行优化</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSumSubmatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length , n = matrix[<span class="number">0</span>].length;       </span><br><span class="line">        <span class="keyword">int</span> res = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)      <span class="comment">//枚举上边界</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; m; j++)  <span class="comment">//枚举下边界</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//计算前缀和</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; n; x++)</span><br><span class="line">                &#123;</span><br><span class="line">                    nums[x] += matrix[j][x];</span><br><span class="line">                &#125;</span><br><span class="line">                TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> TreeSet&lt;Integer&gt;();</span><br><span class="line">                set.add(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)</span><br><span class="line">                &#123;</span><br><span class="line">                    sum += num;</span><br><span class="line">                    Integer tmp = set.ceiling(sum - k); <span class="comment">//寻找最小的S[l] , 使 s[r] - s[l] &lt;= k 有最大值</span></span><br><span class="line">                    <span class="keyword">if</span>(tmp != <span class="keyword">null</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        res = Math.max(res , sum - tmp);    <span class="comment">//注意结果为 ： s[r] - s[l]</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    set.add(sum);       <span class="comment">//加入有序集合中</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>每人一题</tag>
      </tags>
  </entry>
</search>
