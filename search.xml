<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>博客搭建</title>
    <url>/post/f3fb008f.html</url>
    <content><![CDATA[<h1 id="hexo-github搭建静态博客"><a href="#hexo-github搭建静态博客" class="headerlink" title="hexo + github搭建静态博客"></a>hexo + github搭建静态博客</h1><ol>
<li>知乎参考：<a href="https://zhuanlan.zhihu.com/p/26625249?utm_source=qq&utm_medium=social">基本设置</a></li>
<li>csdn博客1：<a href="https://blog.csdn.net/qq_35396510/article/details/105953460">next7.8.0</a></li>
<li>csdn博客2: <a href="https://blog.csdn.net/tuckEnough/article/details/107383201?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-6.control&dist_request_id=1331979.14715.16186627507542321&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-6.control">next7.8.0</a></li>
</ol>
<h2 id="1-工具准备"><a href="#1-工具准备" class="headerlink" title="1.工具准备"></a>1.工具准备</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.安装node.js , hexo , git</span><br><span class="line">2.安装git部署插件： npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<h2 id="2-基本设置"><a href="#2-基本设置" class="headerlink" title="2.基本设置"></a>2.基本设置</h2><ol>
<li>hexo设置参考链接: <a href="https://hexo.io/zh-cn/docs/configuration.html">https://hexo.io/zh-cn/docs/configuration.html</a></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;创建hexo工程</span><br><span class="line">hexo init blog</span><br><span class="line">hexo g			&#x2F;&#x2F;生成静态文件</span><br><span class="line">hexo s 			&#x2F;&#x2F;运行本地服务器</span><br><span class="line">hexo clean		&#x2F;&#x2F;清除缓存</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在站点_config.xml文件中 配置本地hexo上传地址</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:hellohake&#x2F;hellohake.github.io.git</span><br><span class="line">  branch: main</span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F;设置域名解析（CNAME，A，txt字段设置）</span><br><span class="line">hellohake.top 与 hellohake.github.io绑定</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;blog&#x2F;source目录下创建CNAME文件写入域名</span><br><span class="line">hellohake.top</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;站点基本信息配置</span><br><span class="line">title: Hello&#39;s Blog</span><br><span class="line">subtitle: &#39;&#39;</span><br><span class="line">description: 保持好奇</span><br><span class="line">keywords:</span><br><span class="line">author: hellohake</span><br><span class="line">avatar: https:&#x2F;&#x2F;blog.csdn.net&#x2F;hellohake		&#x2F;&#x2F;网站头像外部链接</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone: Asia&#x2F;Shanghai</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;博文打赏微信，支付宝图片，在主题_config.xml文件中配置，将制作好的二维码图片放入themes&#x2F;next&#x2F;source&#x2F;images文件里，并命名为wechatpay.png和alipay.png</span><br><span class="line">wechatpay: &#x2F;images&#x2F;wechatpay.jpg</span><br><span class="line">alipay: &#x2F;images&#x2F;alipay.jpg</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置博客持久化连接</span><br><span class="line">npm install hexo-abbrlink --save	&#x2F;&#x2F;安装</span><br><span class="line">	&#x2F;&#x2F;站点文件配置</span><br><span class="line">	permalink: post&#x2F;:abbrlink.html</span><br><span class="line">    abbrlink:</span><br><span class="line">      alg: crc32  </span><br><span class="line">      rep: hex    </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;添加本地搜索功能 安装到node_modules目录下  本地无法查看</span><br><span class="line">npm install hexo-generator-searchdb --save</span><br><span class="line">  &#x2F;&#x2F;站点配置文件中进行添加</span><br><span class="line">  search:</span><br><span class="line">      path: search.xml</span><br><span class="line">      field: post</span><br><span class="line">      format: html</span><br><span class="line">      limit: 100</span><br><span class="line">  &#x2F;&#x2F;主题配置文件中设置</span><br><span class="line">  local_search:</span><br><span class="line">  	enable: true</span><br></pre></td></tr></table></figure>

<hr>
<p>tips : hexo 写文章创建文件自动打开编辑器 :  编写一段脚本：<a href="https://blog.csdn.net/senupp/article/details/103986447">https://blog.csdn.net/senupp/article/details/103986447</a></p>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210417164929.png" alt="image-20210417164929397"></p>
<h2 id="3-主题美化"><a href="#3-主题美化" class="headerlink" title="3.主题美化"></a>3.主题美化</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;安装next主题（注意从官方clone,不要从第三方clone）</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next.git themes&#x2F;next	&#x2F;&#x2F;helloblog目录下进行</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;站点_config.xml文件中配置主题样式</span><br><span class="line">theme: next</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;主题_config.xml文件中设置主题样式</span><br><span class="line"># Schemes</span><br><span class="line">scheme: Pisces</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Menu增加关于，标签，分类页面</span><br><span class="line">menu:</span><br><span class="line">  home: &#x2F; || fa fa-home</span><br><span class="line">  categories: &#x2F;categories&#x2F; || fa fa-th</span><br><span class="line">  tags: &#x2F;tags&#x2F; || fa fa-tags</span><br><span class="line">  about: &#x2F;about&#x2F; || fa fa-user</span><br><span class="line">	&#x2F;&#x2F;新建相关页面</span><br><span class="line">	hexo new page &quot;about&quot;</span><br><span class="line">	hexo new page &quot;tags&quot;</span><br><span class="line">	hexo new page &quot;categories&quot;</span><br><span class="line">	&#x2F;&#x2F;修改页面文件配置（front matter修改）</span><br><span class="line">	---</span><br><span class="line">    title: 关于</span><br><span class="line">    type: &quot;about&quot;</span><br><span class="line">    ---</span><br><span class="line">    ---</span><br><span class="line">    title: 标签</span><br><span class="line">    type: &quot;tags&quot;</span><br><span class="line">    ---</span><br><span class="line">    ---</span><br><span class="line">    title: 分类</span><br><span class="line">    type: &quot;categories&quot;</span><br><span class="line">    ---</span><br><span class="line">    &#x2F;&#x2F;设置图标，统计信息是否显示</span><br><span class="line">	menu_settings:</span><br><span class="line">  	icons: true   # 显示图标</span><br><span class="line">  	badges: true  # 显示统计信息</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;主题配置文件中，头像设置</span><br><span class="line"># Sidebar Avatar</span><br><span class="line">avatar:</span><br><span class="line">  # Replace the default image and set the url here.</span><br><span class="line">  url: &#x2F;images&#x2F;avatar.png</span><br><span class="line">  # If true, the avatar will be dispalyed in circle.</span><br><span class="line">  rounded: true</span><br><span class="line">  # If true, the avatar will be rotated with the cursor.</span><br><span class="line">  rotated: false</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F;主题配置文件中设置网站图标</span><br><span class="line">favicon:</span><br><span class="line">  small: &#x2F;images&#x2F;h_16.ico</span><br><span class="line">  medium: &#x2F;images&#x2F;h_32.ico</span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F;设置网页代码样式：</span><br><span class="line">codeblock:</span><br><span class="line">  # Code Highlight theme</span><br><span class="line">  # Available values: normal | night | night eighties | night blue | night bright | solarized | solarized dark | galactic</span><br><span class="line">  # See: https:&#x2F;&#x2F;github.com&#x2F;chriskempson&#x2F;tomorrow-theme</span><br><span class="line">  highlight_theme: night eighties</span><br><span class="line">  # Add copy button on codeblock</span><br><span class="line">  copy_button:</span><br><span class="line">    enable: true</span><br><span class="line">    # Show text copy result.</span><br><span class="line">    show_result: true</span><br><span class="line">    # Available values: default | flat | mac</span><br><span class="line">    style: mac</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;页脚配置footer</span><br><span class="line">footer:</span><br><span class="line">  # Specify the date when the site was setup. If not defined, current year will be used.</span><br><span class="line">  since: 2021</span><br><span class="line">  # Powered by Hexo &amp; NexT</span><br><span class="line">  powered: false</span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F;设置左上角或右上角 github 图标</span><br><span class="line">github_banner:</span><br><span class="line">  enable: true</span><br><span class="line">  permalink: https:&#x2F;&#x2F;github.com&#x2F;hellohake</span><br><span class="line">  title: Follow me on GitHub</span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F;使用图标符号代替底部标签</span><br><span class="line">tag_icon: true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置theme-next-three 背景动画（主题目录下）</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-three source&#x2F;lib&#x2F;three</span><br><span class="line">    &#x2F;&#x2F;打开效果</span><br><span class="line">    # three_waves</span><br><span class="line">    three_waves: false</span><br><span class="line">    # canvas_lines</span><br><span class="line">    canvas_lines: true</span><br><span class="line">    # canvas_sphere</span><br><span class="line">    canvas_sphere: false</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;文章末尾显示版权信息</span><br><span class="line"> creative_commons:</span><br><span class="line">  license: by-nc-sa</span><br><span class="line">  sidebar: false</span><br><span class="line">  post: true</span><br><span class="line">  language:</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;图片放大预览</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置tagcloud</span><br><span class="line">npm install hexo-tag-cloud@^2.0.* --save </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;配置gitalk gitalk设置有问题，改用Valine</span><br><span class="line">1. 在github,settings, developer settings 下设置OAuth Apps </span><br><span class="line">未找到相关的 Issues 进行评论 请联系 @hellohake 初始化创建</span><br><span class="line">	&#x2F;&#x2F;Valine评论系统使用说明：</span><br><span class="line">	https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;b9e73c881729</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置打赏</span><br><span class="line">reward_settings:</span><br><span class="line">  # If true, reward will be displayed in every article by default.</span><br><span class="line">  enable: true</span><br><span class="line">  animation: false</span><br><span class="line">  #comment: 打赏</span><br><span class="line"></span><br><span class="line">reward:</span><br><span class="line">  #wechatpay: &#x2F;images&#x2F;wechatpay.jpg</span><br><span class="line">  alipay: &#x2F;images&#x2F;alipay.jpg</span><br><span class="line">  #paypal: &#x2F;images&#x2F;paypal.png</span><br><span class="line">  #bitcoin: &#x2F;images&#x2F;bitcoin.png</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- more --&gt;  &#x2F;&#x2F;设置阅读全文</span><br></pre></td></tr></table></figure>

<h2 id="4-待操作"><a href="#4-待操作" class="headerlink" title="4.待操作"></a>4.待操作</h2><ul>
<li>百度(爬虫屏蔽)，谷歌收录个人博客;</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;orianna-zzo.github.io&#x2F;sci-tech&#x2F;2018-01&#x2F;blog%E5%85%BB%E6%88%90%E8%AE%B05-%E8%A6%81%E8%AE%A9github-pages%E8%A2%AB%E7%B4%A2%E5%BC%95%E5%88%B0&#x2F;</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;duansm.top&#x2F;2018&#x2F;08&#x2F;08&#x2F;hexo-sitemap&#x2F;</span><br></pre></td></tr></table></figure>

<ul>
<li></li>
</ul>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>ETH学习</title>
    <url>/post/3f80cd6e.html</url>
    <content><![CDATA[<h1 id="GTX1660S显卡挖ETH测试"><a href="#GTX1660S显卡挖ETH测试" class="headerlink" title="GTX1660S显卡挖ETH测试"></a>GTX1660S显卡挖ETH测试</h1><p>待操作~</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode_20210412</title>
    <url>/post/7ce22a4f.html</url>
    <content><![CDATA[<h1 id="179-最大数"><a href="#179-最大数" class="headerlink" title="179.最大数"></a>179.最大数</h1><blockquote>
<p>给定一组非负整数 <code>nums</code>，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。</p>
</blockquote>
<hr>
<p><strong>看到2个整数x,y如何拼接得到的结果更大时，先转字符串，然后比较x+y和y+x的大小</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">关键思路：数组转换为字符串进行排序</span><br><span class="line">如果ab拼接比ba好，我们认为a应该放在b的前面（比较器规则）</span><br><span class="line">特殊情况：前导0去除</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Coding</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">largestNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        String[] s = <span class="keyword">new</span> String[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            s[i] = <span class="string">&quot;&quot;</span> + nums[i];</span><br><span class="line">        Arrays.sort(s, (a,b)-&gt;&#123;</span><br><span class="line">            String ab = a + b , ba = b + a;</span><br><span class="line">            <span class="keyword">return</span> ba.compareTo(ab);</span><br><span class="line">        &#125;);</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(String ss : s)</span><br><span class="line">            sb.append(ss);</span><br><span class="line">        <span class="comment">//去除前导0</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(k &lt; n - <span class="number">1</span> &amp;&amp; sb.charAt(k) == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            k++;</span><br><span class="line">        <span class="keyword">return</span> sb.substring(k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="剑指Offer45-把数组排成最小的数"><a href="#剑指Offer45-把数组排成最小的数" class="headerlink" title="剑指Offer45.把数组排成最小的数"></a>剑指Offer45.把数组排成最小的数</h1><blockquote>
<p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p>
</blockquote>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">思路同上</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        String[] ss = <span class="keyword">new</span> String[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            ss[i] = <span class="string">&quot;&quot;</span> + nums[i];</span><br><span class="line">        Arrays.sort(ss, <span class="keyword">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                String s1 = o1 + o2 , s2 = o2 + o1;</span><br><span class="line">                <span class="keyword">return</span> s1.compareTo(s2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(String s : ss)</span><br><span class="line">            sb.append(s);</span><br><span class="line">        <span class="comment">//题目说不用去前导0</span></span><br><span class="line">        <span class="comment">// int k = 0;</span></span><br><span class="line">        <span class="comment">// while(k &lt; n - 1 &amp;&amp; sb.charAt(k) == &#x27;0&#x27;)</span></span><br><span class="line">        <span class="comment">//     k++;</span></span><br><span class="line">        <span class="comment">// return sb.substring(k);</span></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">思路2：使用小根堆，将字典序小的放在堆顶（O1 + O2 &gt; O2 + O1)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Coding</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1 , String o2)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="comment">//字典序小的放在栈顶</span></span><br><span class="line">                <span class="keyword">return</span> (o1 + o2).compareTo(o2 + o1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)</span><br><span class="line">            queue.add(<span class="string">&quot;&quot;</span> + num);</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())</span><br><span class="line">            sb.append(queue.poll());</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode_20210413</title>
    <url>/post/e1edcb39.html</url>
    <content><![CDATA[<h1 id="783-二叉搜索树节点的最小距离"><a href="#783-二叉搜索树节点的最小距离" class="headerlink" title="783. 二叉搜索树节点的最小距离"></a>783. 二叉搜索树节点的最小距离</h1><blockquote>
<p>给你一个二叉搜索树的根节点 <code>root</code> ，返回 <strong>树中任意两不同节点值之间的最小差值</strong> 。</p>
</blockquote>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">思路： 考察二叉搜索树中序遍历有序的特点，两不同节点值之间的最小差值一定在相邻两元素之间</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//迭代实现（模拟栈）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDiffInBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">//中序遍历</span></span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span> || !stack.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(root != <span class="keyword">null</span>)</span><br><span class="line">            &#123;               </span><br><span class="line">                stack.addLast(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pollLast();</span><br><span class="line">            <span class="keyword">if</span>(pre != <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                min = Math.min(min , root.val - pre.val);</span><br><span class="line">            &#125;</span><br><span class="line">            pre = root;         <span class="comment">//保存前一个结点</span></span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDiffInBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            min = Math.min(root.val - pre.val , min);</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root;     <span class="comment">//更新pre为前一个结点</span></span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode_20210417</title>
    <url>/post/6a766917.html</url>
    <content><![CDATA[<h1 id="220-存在重复元素III"><a href="#220-存在重复元素III" class="headerlink" title="220.存在重复元素III"></a>220.存在重复元素III</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给你一个整数数组 nums 和两个整数 k 和 t 。请你判断是否存在 两个不同下标 i 和 j，使得 abs(nums[i] - nums[j]) &lt;&#x3D; t ，同时又满足 abs(i - j) &lt;&#x3D; k 。</span><br><span class="line"></span><br><span class="line">如果存在则返回 true，不存在返回 false。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路： 滑动窗口 + 双指针，<code>TreeSet</code>的使用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        TreeSet&lt;Long&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">long</span> u = nums[i];</span><br><span class="line">            Long min = set.floor(u);    <span class="comment">//找到小于等于u的最接近u的数</span></span><br><span class="line">            Long max = set.ceiling(u);  <span class="comment">//找到大于等于u的最小值</span></span><br><span class="line">            <span class="keyword">if</span>(min != <span class="keyword">null</span> &amp;&amp; u - min &lt;= t)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(max != <span class="keyword">null</span> &amp;&amp; max - u &lt;= t)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//维护窗口大小k</span></span><br><span class="line">            set.add(u);</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k)</span><br><span class="line">                set.remove(nums[i-k] * <span class="number">1L</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路2：桶排序</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode_20210414</title>
    <url>/post/28aa04ef.html</url>
    <content><![CDATA[<h1 id="208-实现Trie-前缀树"><a href="#208-实现Trie-前缀树" class="headerlink" title="208.实现Trie(前缀树)"></a>208.实现Trie(前缀树)</h1><p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210414093343.png" alt="image-20210414093343520"></p>
<hr>
<blockquote>
<p>思路：<strong>前缀树</strong>是一颗<strong>非典型的多叉树模型</strong>：<strong>前缀树不存储具体的字符值，使用字符映射表将具体的值映射为数组下标</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//多叉树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">ValueType value;</span><br><span class="line">TreeNode children = <span class="keyword">new</span> TreeNode[num];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前缀树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span></span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> isLeaf;		<span class="comment">//是否是叶子结点</span></span><br><span class="line">TrieNode children = <span class="keyword">new</span> TrieNode[num];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//coding</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Trie[] node;</span><br><span class="line">    <span class="keyword">boolean</span> isLeaf;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        node = <span class="keyword">new</span> Trie[<span class="number">26</span>];</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        Trie t = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(t.node[word.charAt(i) - <span class="string">&#x27;a&#x27;</span>] == <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                t.node[word.charAt(i) - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> Trie();</span><br><span class="line">            &#125;</span><br><span class="line">            t = t.node[word.charAt(i) - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        t.isLeaf = <span class="keyword">true</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        Trie t = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(t.node[word.charAt(i) - <span class="string">&#x27;a&#x27;</span>] == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                t = t.node[word.charAt(i) - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t.isLeaf;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        Trie t = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(t.node[prefix.charAt(i) - <span class="string">&#x27;a&#x27;</span>] == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                t = t.node[prefix.charAt(i) - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>N皇后</title>
    <url>/post/bd497d25.html</url>
    <content><![CDATA[<h1 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h1><ul>
<li>LeetCode 51题：</li>
</ul>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210413162600.png" alt="image-20210413162559960"></p>
<hr>
<blockquote>
<p>思路：回溯暴力搜索，棋盘格对应位置是否可填充皇后取决于其左上、左下、右上、右下是否含有皇后（<strong>判断条件</strong>）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Coding</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt;  res  =  <span class="keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[][]  chess = <span class="keyword">new</span> <span class="keyword">char</span>[n][n];</span><br><span class="line">        <span class="comment">//填充初始棋盘</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                chess[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        dfs(<span class="number">0</span> , res , chess);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> row , List&lt;List&lt;String&gt;&gt;  res  ,   <span class="keyword">char</span>[][] chess)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row == chess.length)</span><br><span class="line">        &#123;</span><br><span class="line">            res.add(copy(chess));           <span class="comment">//深拷贝</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//做选择</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>;  col &lt; chess[<span class="number">0</span>].length;  col++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(isVaild(chess , row , col))</span><br><span class="line">            &#123;</span><br><span class="line">                chess[row][col] = <span class="string">&#x27;Q&#x27;</span>;  <span class="comment">//选择</span></span><br><span class="line">                dfs(row + <span class="number">1</span> , res , chess);             <span class="comment">//递归</span></span><br><span class="line">                chess[row][col] = <span class="string">&#x27;.&#x27;</span>;  <span class="comment">//回溯</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">copy</span><span class="params">(<span class="keyword">char</span>[][] chess)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;String&gt;  ret = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chess.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            StringBuilder tmp = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; chess[<span class="number">0</span>].length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp.append(chess[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            ret.add(tmp.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isVaild</span><span class="params">(<span class="keyword">char</span>[][] chess,  <span class="keyword">int</span> row , <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> n = chess.length;</span><br><span class="line">        <span class="comment">//(row , col)上方列是否包含Q</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(chess[i][col] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//(row , col)左上方判断</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = row - <span class="number">1</span> , j = col - <span class="number">1</span>;  i  &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span> ; i-- , j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(chess[i][j] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//(row, col)右上方判断</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>  i = row - <span class="number">1</span> ,  j = col + <span class="number">1</span>;  i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i-- , j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(chess[i][j] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>背包</title>
    <url>/post/bfd1492e.html</url>
    <content><![CDATA[<h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><p>Mark一下力扣上背包各种类型题目;</p>
<h2 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h2><h3 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416-分割等和子集"></a>416-分割等和子集</h3><blockquote>
<p>给定一个<strong>只包含正整数</strong>的<strong>非空</strong>数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
</blockquote>
<blockquote>
<p>问题转换： 先对集合求和sum,</p>
<p>给一个可装载重量为sum/2 的背包和N个物品，每个物品重量为nums[i] , 能否存在一种装法，将背包恰好装满；</p>
<p>dp数组定义:   dp[i][j] :   背包容量为j ,   前i个物品能否将该背包装满；</p>
<p>状态转移方程：  dp[i][j]  =   dp[i-1][j] || dp[i-1][j - nums[i-1]](j - nums[i-1] &gt; = 0)    //可以选择装还是不装该物品；</p>
<p>dp[i][j] = dp[i-1][j]   (j - nums[i-1] &lt; 0)</p>
<p>base case :  dp[0][..]  = false;   dp[..][0]  = true;</p>
<p>填表方向：从左到右，从上到下</p>
<p>状态压缩：使用滚动数组对dp数组进行优化</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C++</span></span><br><span class="line"><span class="function">bool <span class="title">canPartition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) sum += num;</span><br><span class="line">    <span class="comment">// 和为奇数时，不可能划分成两个和相等的集合</span></span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    sum = sum / <span class="number">2</span>;</span><br><span class="line">    vector&lt;vector&lt;bool&gt;&gt; </span><br><span class="line">        dp(n + <span class="number">1</span>, vector&lt;bool&gt;(sum + <span class="number">1</span>, <span class="keyword">false</span>));</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= sum; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j - nums[i - <span class="number">1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">// 背包容量不足，不能装入第 i 个物品</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j]; </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 装入或不装入背包</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] || dp[i - <span class="number">1</span>][j-nums[i-<span class="number">1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>状态压缩：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> e : nums)</span><br><span class="line">            sum += e;</span><br><span class="line">        <span class="keyword">if</span>(sum % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        sum /= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[sum+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = sum; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j - nums[i-<span class="number">1</span>] &gt;= <span class="number">0</span>)</span><br><span class="line">                    dp[j] = dp[j] || dp[j - nums[i-<span class="number">1</span>]];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[j] = dp[j];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[sum];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322.零钱兑换"></a>322.零钱兑换</h3><blockquote>
<p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
</blockquote>
<hr>
<hr>
<blockquote>
<p>完全背包：dp[j] = min(dp[j - coin[i]] + 1)</p>
<p>dp数组求最大值则初始化最小值，求最小值则初始化最大值</p>
<p>参考：<a href="https://mp.weixin.qq.com/s/dyk-xNilHzNtVdPPLObSeQ">https://mp.weixin.qq.com/s/dyk-xNilHzNtVdPPLObSeQ</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(amount == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class="line">        <span class="comment">//边界</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//排列数，组合数不重要（这题）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coins.length; i++)   <span class="comment">//外层物品（组合数）</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = coins[i]; j &lt;= amount; j++)    <span class="comment">//完全背包，正序遍历</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j - coins[i]] != Integer.MAX_VALUE)   <span class="comment">//有意义的值才计算</span></span><br><span class="line">                    dp[j] = Math.min(dp[j] , dp[j - coins[i]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[amount] == Integer.MAX_VALUE)     <span class="comment">//无法凑出</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="377-组合总和IV"><a href="#377-组合总和IV" class="headerlink" title="377.组合总和IV"></a>377.组合总和IV</h3><blockquote>
<p>给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。</p>
<p>题目数据保证答案符合 32 位整数范围。</p>
</blockquote>
<hr>
<hr>
<blockquote>
<p>背包问题，求<strong>排列数</strong>；</p>
<p><strong>外层背包，内层物品</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//base</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;      <span class="comment">//该元素赋值无意义，仅用于计算</span></span><br><span class="line">        <span class="comment">//背包排列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= target; i++)        <span class="comment">//外层背包</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++)    <span class="comment">//内层物品</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt;= nums[j])</span><br><span class="line">                    dp[i] += dp[i - nums[j]];   <span class="comment">//防止溢出</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="518-零钱兑换-II"><a href="#518-零钱兑换-II" class="headerlink" title="518.零钱兑换 II"></a>518.<a href="https://leetcode-cn.com/problems/coin-change-2/">零钱兑换 II</a></h3><blockquote>
<p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 </p>
</blockquote>
<hr>
<hr>
<blockquote>
<p>求组合数：外层遍历物品，内层遍历背包</p>
<p>求排列数：外层遍历背包，内层遍历物品</p>
<p>组合数状态转移方程：dp[i] += dp[i-coin[j]];</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//求组合数</span></span><br><span class="line">        <span class="keyword">if</span>(amount == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] =<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//求组合数，外层遍历物品，里层遍历背包</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coins.length; i++)       <span class="comment">//遍历物品</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = coins[i]; j &lt;= amount; j++) <span class="comment">//遍历背包</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[j] += dp[j - coins[i]];      <span class="comment">//状态转移方程</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494.目标和"></a>494.目标和</h3><blockquote>
<p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。</p>
<p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p>
</blockquote>
<hr>
<hr>
<blockquote>
<p>参考：<a href="https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&amp;mid=2247486709&amp;idx=1&amp;sn=75f1f43d96dbd1c5c3e281b8963e3c50&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&amp;mid=2247486709&amp;idx=1&amp;sn=75f1f43d96dbd1c5c3e281b8963e3c50&amp;scene=21#wechat_redirect</a></p>
<p>A - B = S;</p>
<p>A + B = sum；</p>
<p>A = (S + sum) / 2;</p>
<p><strong>求数组中和为A的组合数</strong></p>
<p>一维dp遍历时，内层循环倒数遍历，保证物品i只放入1次</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> e : nums)</span><br><span class="line">            sum += e;</span><br><span class="line">        <span class="keyword">if</span>(S &gt; sum)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(((sum + S) % <span class="number">2</span>) == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> T = (sum + S) / <span class="number">2</span>;      <span class="comment">//求装满背包T的组合数</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[T+<span class="number">1</span>];    </span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)    <span class="comment">//外层物品</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = T; j &gt;= nums[i]; j--)    <span class="comment">//内层背包,倒序遍历保证每个物品只添加一次（01背包，不是完全背包）</span></span><br><span class="line">                dp[j] += dp[j - nums[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[T];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode_20210418</title>
    <url>/post/fac97486.html</url>
    <content><![CDATA[<h1 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26.删除有序数组中的重复项"></a>26.删除有序数组中的重复项</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。</span><br><span class="line"></span><br><span class="line">不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路：双指针i , j ，，，指针i指向已删除后不带重复项的元素，指针j指向原数组</p>
<p>比较i, j 对应位置是否相等</p>
<p>如果相等，j后移一位</p>
<p>如果不等，将j位置元素复制到i + 1处，i++，</p>
<p>新数组长度： i + 1</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>( ; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] == nums[i])</span><br><span class="line">            &#123;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums[++i] = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//写法2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span> , j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != nums[j])</span><br><span class="line">            &#123;</span><br><span class="line">                nums[++i] = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>lc-438</title>
    <url>/post/bd35841e.html</url>
    <content><![CDATA[<h1 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a>438. <a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">找到字符串中所有字母异位词</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。</span><br><span class="line"></span><br><span class="line">字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line">字母异位词指字母相同，但排列不同的字符串。</span><br><span class="line">不考虑答案输出的顺序。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路1：滑动窗口 + 数组 + Arrays.equals()方法使用</p>
<p>首先建立一个大小为m的窗口，然后进行滑窗，每次滑动后比较2出现次数数组是否相等，相等则添加对应数组下标</p>
<p>时间复杂度：O(n)   空间复杂度： O(1)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length() , m = p.length();</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(n &lt; m)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span>[] pCnt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span>[] sCnt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            pCnt[p.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            sCnt[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Arrays.equals(sCnt , pCnt))</span><br><span class="line">            res.add(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = m ; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sCnt[s.charAt(i - m) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            sCnt[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            <span class="keyword">if</span>(Arrays.equals(sCnt , pCnt))</span><br><span class="line">                res.add(i - m + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路2： 使用滑动窗口 + 双指针，使用双指针表示滑动窗口的左右边界，当滑动窗口长度为p的长度时，保是找到一个异位词</p>
<p>注意Coding</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length() , m = p.length();</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(n &lt; m)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span>[] pCnt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span>[] sCnt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="comment">//统计字符出现次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            pCnt[p.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(; right &lt; n; right++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> curRight = s.charAt(right) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            sCnt[curRight]++;</span><br><span class="line">            <span class="keyword">while</span>(sCnt[curRight] &gt; pCnt[curRight])  <span class="comment">//最坏情况，left 与right 重合</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> curLeft = s.charAt(left) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                sCnt[curLeft]--;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(right - left + <span class="number">1</span> == m)   <span class="comment">//滑动窗口大小为m时，符合条件，添加数组元素对应下标</span></span><br><span class="line">                res.add(left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>热题100道</category>
      </categories>
      <tags>
        <tag>热题100道</tag>
      </tags>
  </entry>
  <entry>
    <title>lc_20210419</title>
    <url>/post/561b7852.html</url>
    <content><![CDATA[<h1 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27.移除元素"></a>27.移除元素</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</span><br><span class="line"></span><br><span class="line">不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</span><br><span class="line"></span><br><span class="line">元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路：使用双指针，左指针指向下一个将要赋值的位置，右指针指向当前要处理的元素；</p>
<p>画图分析返回数据的长度是 i  还是 i + 1;</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] != val)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>第一种方法缺点，如果要删除的元素位于数组开头，大部分元素都需要移动，时间复杂度比较高，可以设置分别指向左右边界的指针，进行交换，<strong>数组中元素顺序可以改变！！</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span> , right = n;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left] == val)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[left] = nums[right - <span class="number">1</span>];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>lc-621</title>
    <url>/post/de76d995.html</url>
    <content><![CDATA[<h1 id="621-任务调度器"><a href="#621-任务调度器" class="headerlink" title="621. 任务调度器"></a><a href="https://leetcode-cn.com/problems/task-scheduler/">621. 任务调度器</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给你一个用字符数组 tasks 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。</span><br><span class="line"></span><br><span class="line">然而，两个 相同种类 的任务之间必须有长度为整数 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。</span><br><span class="line"></span><br><span class="line">你需要计算完成所有任务所需要的 最短时间 。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路：桶思想，完成所有任务的最短时间取决于出现次数最多的任务数量；</p>
<p>贪心思想：优先安排出现次数最多的任务，让该任务两次执行的时间恰好为n，在这个时间间隔内填充其他任务；</p>
<p>计算公式：max( 并行最大任务数 +  （并行最大次数 - 1） * （ n + 1）(n为冷却时间)  ,   任务数组长度);</p>
<p>情况1：</p>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210419152356.png" alt="image-20210419152356496"></p>
<p>情况2：</p>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210419152404.png" alt="image-20210419152404886"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//coding1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(<span class="keyword">char</span>[] tasks, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//统计各任务出现次数</span></span><br><span class="line">        <span class="keyword">int</span> t = tasks.length;</span><br><span class="line">        <span class="keyword">int</span>[] taskCnt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; i++)</span><br><span class="line">            taskCnt[tasks[i] - <span class="string">&#x27;A&#x27;</span>]++;</span><br><span class="line">        Arrays.sort(taskCnt);   <span class="comment">//具体是哪个任务最多出现次数不重要</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;            <span class="comment">//最大并行任务数统计</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">25</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(taskCnt[i] == taskCnt[<span class="number">25</span>])</span><br><span class="line">                cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(t , cnt + (taskCnt[<span class="number">25</span>] - <span class="number">1</span>) * (n + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>热题100道</category>
      </categories>
      <tags>
        <tag>热题100道</tag>
      </tags>
  </entry>
  <entry>
    <title>lc-581</title>
    <url>/post/26df8f46.html</url>
    <content><![CDATA[<h1 id="581-最短无序连续子数组"><a href="#581-最短无序连续子数组" class="headerlink" title="581.最短无序连续子数组"></a>581.<a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/">最短无序连续子数组</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给你一个整数数组 nums ，你需要找出一个 连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</span><br><span class="line">请你找出符合题意的 最短 子数组，并输出它的长度。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路1 ： 首先进行排序，然后比较左边界和右边界第一个不同的位置</p>
<p>时间复杂度： O(nlogn)</p>
<p>空间复杂度： O(n)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] cnum = nums.clone();</span><br><span class="line">        Arrays.sort(cnum);</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span> , right = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnum[i] != nums[i])</span><br><span class="line">            &#123;</span><br><span class="line">                left = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnum[i] != nums[i])</span><br><span class="line">            &#123;</span><br><span class="line">                right = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right - left == n ? <span class="number">0</span> : right - left + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//写法2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] cnum = nums.clone();</span><br><span class="line">        Arrays.sort(cnum);</span><br><span class="line">        <span class="keyword">int</span> left = n , right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnum[i] != nums[i])</span><br><span class="line">            &#123;</span><br><span class="line">                left = Math.min(left, i);</span><br><span class="line">                right = Math.max(right , i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> right - left &lt; <span class="number">0</span> ? <span class="number">0</span> : right - left + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路2：选择排序，找到无序子数组中最小元素和最大元素分别对应的正确位置，来确定无序子数组的边界</p>
<p>使用栈，时间复杂度：O(n)  空间复杂度： O(n)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> left = n , right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; nums[stack.peek()] &gt; nums[i])</span><br><span class="line">                left = Math.min(left , stack.poll());</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        stack.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; nums[stack.peek()] &lt; nums[i])</span><br><span class="line">                right = Math.max(right , stack.poll());</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right - left &gt; <span class="number">0</span> ? right - left + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>暴力方法</p>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210419144917.png" alt="image-20210419144917134"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> left = n - <span class="number">1</span> , right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n -<span class="number">1</span>; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &lt; nums[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    right = Math.max(right , j);</span><br><span class="line">                    left = Math.min(left , i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> right - left &gt; <span class="number">0</span> ? right - left + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>热题100道</category>
      </categories>
      <tags>
        <tag>热题100道</tag>
      </tags>
  </entry>
  <entry>
    <title>lc-253</title>
    <url>/post/783086a2.html</url>
    <content><![CDATA[<h1 id="253-会议室II"><a href="#253-会议室II" class="headerlink" title="253. 会议室II"></a>253. 会议室II</h1><blockquote>
<p>给定一个会议时间安排的数组，每个会议时间都会包括开始和结束的时间 [[s1,e1],[s2,e2],…] (si &lt; ei)，为避免会议冲突，同时要考虑充分利用会议室资源，请你计算至少需要多少间会议室，才能满足这些会议安排。</p>
<p>示例 1:</p>
<p>输入: [[0, 30],[5, 10],[15, 20]]<br>输出: 2<br>示例 2:</p>
<p>输入: [[7,10],[2,4]]<br>输出: 1</p>
</blockquote>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">热题100道最后一道会员题，哈哈，总算刷完基础100道了~</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路：使用最小堆+数组排序</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMeetingRooms</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; allocator = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(intervals.length , (a , b) -&gt; a- b);</span><br><span class="line">        <span class="comment">//对时间表按照开始时间从小到大排序</span></span><br><span class="line">        Arrays.sort(intervals , (a ,b) -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//添加第一场会议</span></span><br><span class="line">        allocator.add(intervals[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//遍历除第一场会议之外的所有会议</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &gt;= allocator.peek())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//如果当前会议的开始时间大于前面已经开始的会议中最晚结束的时间,则该会议室可以重复使用</span></span><br><span class="line">                allocator.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//把当前会议结束时间加入最小堆中</span></span><br><span class="line">            allocator.add(intervals[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当所有会议遍历完毕，还在最小堆里面的，说明会议还没结束，此时的数量就是会议室的最少数量</span></span><br><span class="line">        <span class="keyword">return</span> allocator.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>热题100道</category>
      </categories>
      <tags>
        <tag>热题100道</tag>
      </tags>
  </entry>
  <entry>
    <title>jzOffer-68-II</title>
    <url>/post/1e8bcec9.html</url>
    <content><![CDATA[<h1 id="剑指-Offer-68-II-二叉树的最近公共祖先"><a href="#剑指-Offer-68-II-二叉树的最近公共祖先" class="headerlink" title="剑指 Offer 68 - II. 二叉树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - II. 二叉树的最近公共祖先</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</span><br><span class="line"></span><br><span class="line">百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</span><br><span class="line"></span><br><span class="line">例如，给定如下二叉树:  root &#x3D; [3,5,1,6,2,0,8,null,null,7,4]</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路：递归，后序遍历，从底向上进行搜索；</p>
<p>公共祖先有3种分布情况：</p>
<ol>
<li>p和 q在 root的子树中，且分列 root的 <strong>异侧</strong>；    2. <em>p</em>=root , q在ro<strong>o</strong>t 的左或右子树中；    3. <em>q</em>=<em>r<strong>o</strong>o**t</em> ，且 p<em>p</em> 在 root<em>r<strong>o</strong>o**t</em> 的左或右子树中；</li>
</ol>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210420102139.png" alt="image-20210420102138999"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || root == p || root == q)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">//后序遍历，从底向上进行搜索</span></span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left , p , q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right , p , q);</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span>(right == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="剑指-Offer-68-I-二叉搜索树的最近公共祖先"><a href="#剑指-Offer-68-I-二叉搜索树的最近公共祖先" class="headerlink" title="剑指 Offer 68 - I. 二叉搜索树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</span><br><span class="line"></span><br><span class="line">百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路：利用二叉搜索树有序的特点</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.val &gt; root.val &amp;&amp; q.val &gt; root.val)</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.right , p ,q);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p.val &lt; root.val &amp;&amp; q.val &lt; root.val)</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.left , p ,q);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//迭代写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        TreeNode res = root;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(res.val &gt; p.val &amp;&amp; res.val &gt; q.val)</span><br><span class="line">            &#123;</span><br><span class="line">                res = res.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(res.val &lt; p.val &amp;&amp; res.val &lt; q.val)</span><br><span class="line">            &#123;</span><br><span class="line">                res = res.right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>lc-28</title>
    <url>/post/46940ce0.html</url>
    <content><![CDATA[<h1 id="28-实现strStr"><a href="#28-实现strStr" class="headerlink" title="28.实现strStr()"></a>28.实现strStr()</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">实现 strStr() 函数。</span><br><span class="line">给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。</span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line">当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</span><br><span class="line">对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>KMP算法：考虑怎么计算next数组，部分匹配表；背模板</p>
<p>复杂度分析：原串长度n，模式串长度m，时间复杂度O(n + m) , 空间复杂度O(m)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = haystack.length() , m = needle.length();</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        haystack = <span class="string">&quot; &quot;</span> + haystack;</span><br><span class="line">        needle = <span class="string">&quot; &quot;</span> + needle;</span><br><span class="line">        <span class="keyword">char</span>[] s = haystack.toCharArray() , p = needle.toCharArray();</span><br><span class="line">        <span class="comment">//计算next数组</span></span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> , j = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; p[i] != p[j+<span class="number">1</span>])  <span class="comment">//匹配不成功，进行回溯</span></span><br><span class="line">                j = next[j];</span><br><span class="line">            <span class="keyword">if</span>(p[j+<span class="number">1</span>] == p[i])      <span class="comment">//匹配成功</span></span><br><span class="line">                j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//原串和模式串匹配</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> , j = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != p[j+<span class="number">1</span>])</span><br><span class="line">                j = next[j];</span><br><span class="line">            <span class="keyword">if</span>(s[i] == p[j+<span class="number">1</span>])</span><br><span class="line">                j++;</span><br><span class="line">            <span class="keyword">if</span>(j == m)</span><br><span class="line">                <span class="keyword">return</span> i - m;   <span class="comment">//整段匹配成功，返回下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路2：  暴力计算，</p>
<p>时间复杂度：原串n , 模式串m ,   O((n - m) * m)</p>
<p>空间复杂度： O(1)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = haystack.length() , m = needle.length();</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>[] s = haystack.toCharArray() , p = needle.toCharArray();</span><br><span class="line">        <span class="comment">//暴力匹配</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - m; i++)		<span class="comment">//注意这里带=号</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k = i , j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; m &amp;&amp; s[k] == p[j])</span><br><span class="line">            &#123;</span><br><span class="line">                k++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j == m)  <span class="comment">//完全匹配</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>jc32-III</title>
    <url>/post/c4f06753.html</url>
    <content><![CDATA[<h1 id="剑指-Offer-32-III-从上到下打印二叉树-III"><a href="#剑指-Offer-32-III-从上到下打印二叉树-III" class="headerlink" title="剑指 Offer 32 - III. 从上到下打印二叉树 III"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">剑指 Offer 32 - III. 从上到下打印二叉树 III</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路：BFS ，层序遍历</p>
<p>奇数层添加到tmp的头部</p>
<p>偶数层添加到tmp的尾部</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Deque&lt;TreeNode&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        queue.addLast(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();     </span><br><span class="line">            LinkedList&lt;Integer&gt; tmp = <span class="keyword">new</span> LinkedList&lt;&gt;();  </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode node = queue.pollFirst();</span><br><span class="line">                <span class="keyword">if</span>(res.size() % <span class="number">2</span> == <span class="number">0</span>)     <span class="comment">//偶数层，队列头部</span></span><br><span class="line">                    tmp.addLast(node.val);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    tmp.addFirst(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)</span><br><span class="line">                    queue.addLast(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)</span><br><span class="line">                    queue.addLast(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>一次打印2层</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Deque&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.addLast(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            LinkedList&lt;Integer&gt; tmp = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)       <span class="comment">//奇数层</span></span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode node = queue.pollFirst();</span><br><span class="line">                tmp.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)</span><br><span class="line">                    queue.addLast(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)</span><br><span class="line">                    queue.addLast(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">            tmp = <span class="keyword">new</span> LinkedList&lt;&gt;();            <span class="comment">//清空</span></span><br><span class="line">            size = queue.size();    <span class="comment">//偶数层</span></span><br><span class="line">            <span class="keyword">if</span>(size == <span class="number">0</span>)           <span class="comment">//偶数层没有，直接跳出</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)       <span class="comment">//奇数层</span></span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode node = queue.pollLast();   <span class="comment">//从右向左打印</span></span><br><span class="line">                tmp.addLast(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)</span><br><span class="line">                    queue.addFirst(node.right);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)</span><br><span class="line">                    queue.addFirst(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>jz-33</title>
    <url>/post/6a0c099c.html</url>
    <content><![CDATA[<h1 id="剑指-Offer-33-二叉搜索树的后序遍历序列"><a href="#剑指-Offer-33-二叉搜索树的后序遍历序列" class="headerlink" title="剑指 Offer 33. 二叉搜索树的后序遍历序列"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">剑指 Offer 33. 二叉搜索树的后序遍历序列</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210421171510.png" alt="image-20210421171510668"></p>
<hr>
<blockquote>
<p>递归：</p>
<p>1 3 2[左子树]   6[右子树]   5[根]</p>
<p>–&gt;二叉搜索树特性：左子树区间所有元素都小于根结点，右子树区间所有元素都大于根节点元素</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyPostorder</span><span class="params">(<span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertify(postorder, <span class="number">0</span> , postorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">vertify</span><span class="params">(<span class="keyword">int</span>[] postorder , <span class="keyword">int</span> i , <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= j)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> p = i;</span><br><span class="line">        <span class="keyword">while</span>(postorder[p] &lt; postorder[j])</span><br><span class="line">            p++;</span><br><span class="line">        <span class="keyword">int</span> m = p;</span><br><span class="line">        <span class="keyword">while</span>(postorder[p] &gt; postorder[j])</span><br><span class="line">            p++;</span><br><span class="line">        <span class="keyword">return</span> p == j &amp;&amp; vertify(postorder , i , m - <span class="number">1</span>) &amp;&amp; vertify(postorder , m, j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>辅助栈：</p>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210421172404.png" alt="image-20210421172404626"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyPostorder</span><span class="params">(<span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> root = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = postorder.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(postorder[i] &gt; root) </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peekLast() &gt; postorder[i])</span><br><span class="line">                root = stack.pollLast();</span><br><span class="line">            stack.addLast(postorder[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>美团暑期实习算法题</title>
    <url>/post/b9706eda.html</url>
    <content><![CDATA[<h1 id="39-组合总数（力扣）"><a href="#39-组合总数（力扣）" class="headerlink" title="39.组合总数（力扣）"></a>39.组合总数（力扣）</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</span><br><span class="line"></span><br><span class="line">candidates 中的数字可以无限制重复被选取。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>回溯，暴力搜索 + 部分剪枝，面试前一个月做的，然后具体细节有些忘了，然后run了爆栈。。。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(candidates.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        dfs(<span class="number">0</span> , candidates , target , <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> idx , <span class="keyword">int</span>[] candidates , <span class="keyword">int</span> target , <span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(idx == candidates.length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum == target)</span><br><span class="line">        &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tmp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; target)    <span class="comment">//剪枝</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//不选择当前元素</span></span><br><span class="line">        dfs(idx + <span class="number">1</span> , candidates, target ,sum);</span><br><span class="line">        <span class="comment">//选择</span></span><br><span class="line">        tmp.add(candidates[idx]);</span><br><span class="line">        dfs(idx, candidates , target , sum + candidates[idx]);  <span class="comment">//下一步递归仍然可能选择该元素</span></span><br><span class="line">        tmp.remove(tmp.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>写法2：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(candidates.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        dfs(<span class="number">0</span> , candidates , target , <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> idx , <span class="keyword">int</span>[] candidates , <span class="keyword">int</span> target , <span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(idx == candidates.length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum == target)</span><br><span class="line">        &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tmp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = idx ; i &lt; candidates.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(sum + candidates[i] &lt;= target)   <span class="comment">//剪枝</span></span><br><span class="line">            &#123;</span><br><span class="line">                tmp.add(candidates[i]);</span><br><span class="line">                dfs(i , candidates , target , sum + candidates[i]);</span><br><span class="line">                tmp.remove(tmp.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="40-组合总数II-力扣"><a href="#40-组合总数II-力扣" class="headerlink" title="40.组合总数II(力扣)"></a>40.组合总数II(力扣)</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</span><br><span class="line"></span><br><span class="line">candidates 中的每个数字在每个组合中只能使用一次。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>这里需要去重，回溯 + 剪枝 + 去重</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = candidates.length;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        dfs(<span class="number">0</span> , candidates , target , <span class="number">0</span> , res , tmp);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> idx , <span class="keyword">int</span>[] candidates , <span class="keyword">int</span> target , <span class="keyword">int</span> sum , List&lt;List&lt;Integer&gt;&gt; res , List&lt;Integer&gt; tmp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == target)</span><br><span class="line">        &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tmp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = idx ; i &lt; candidates.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(sum + candidates[i] &gt; target)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; idx &amp;&amp; candidates[i] == candidates[i-<span class="number">1</span>])  <span class="comment">//下一个元素相同直接跳过</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            tmp.add(candidates[i]);                </span><br><span class="line">            dfs(i + <span class="number">1</span>, candidates , target , sum + candidates[i] , res , tmp);  <span class="comment">//不可选择重复元素</span></span><br><span class="line">            tmp.remove(tmp.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>























]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>lc-91</title>
    <url>/post/dcbc6d8f.html</url>
    <content><![CDATA[<h1 id="91-解码方法"><a href="#91-解码方法" class="headerlink" title="91. 解码方法"></a><a href="https://leetcode-cn.com/problems/decode-ways/">91. 解码方法</a></h1><p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210421145236.png" alt="image-20210421145236136"></p>
<hr>
<blockquote>
<p>思路：dp动态规划</p>
<p>dp[i] :  以i结尾的字符串解码方法总数</p>
<p>状态转移方程：</p>
<p>dp[i] = dp[i-1] (s[i-1] != ‘0’)</p>
<p>dp[i] = dp[i-2] (s[i-2] != ‘0’ &amp;&amp; 10 * (s[i-2] - ‘0’) + s[i-1] - ‘0’ &lt;= 26)</p>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210421150139.png" alt="image-20210421150139163"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//边界</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i - <span class="number">1</span>) != <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] += dp[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">1</span> &amp;&amp; s.charAt(i - <span class="number">2</span>) != <span class="string">&#x27;0&#x27;</span> &amp;&amp; (<span class="number">10</span> * (s.charAt(i-<span class="number">2</span>) - <span class="string">&#x27;0&#x27;</span>) + s.charAt(i - <span class="number">1</span>) - <span class="string">&#x27;0&#x27;</span>) &lt;= <span class="number">26</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] += dp[i-<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>jz-55-II</title>
    <url>/post/67391d39.html</url>
    <content><![CDATA[<h1 id="剑指-Offer-55-II-平衡二叉树"><a href="#剑指-Offer-55-II-平衡二叉树" class="headerlink" title="剑指 Offer 55 - II. 平衡二叉树"></a><a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/">剑指 Offer 55 - II. 平衡二叉树</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路：递归计算左右子树的深度，判断其深度相差是否超过1</p>
<p>后续遍历 + 剪枝，从二叉树底部开始向上进行遍历</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> depth(root) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = depth(root.left);</span><br><span class="line">        <span class="keyword">if</span>(left == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = depth(root.right);</span><br><span class="line">        <span class="keyword">if</span>(right == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(right - left) &lt; <span class="number">2</span> ? Math.max(right , left) + <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>写法2：计算深度，先序遍历，存在大量重复计算</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(depth(root.left) - depth(root.right)) &lt; <span class="number">2</span> &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = depth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = depth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left , right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>lc-363</title>
    <url>/post/52dfbf56.html</url>
    <content><![CDATA[<h1 id="363-矩形区域不超过-K-的最大数值和"><a href="#363-矩形区域不超过-K-的最大数值和" class="headerlink" title="363.矩形区域不超过 K 的最大数值和"></a>363.<a href="https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/">矩形区域不超过 K 的最大数值和</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给你一个 m x n 的矩阵 matrix 和一个整数 k ，找出并返回矩阵内部矩形区域的不超过 k 的最大数值和。</span><br><span class="line"></span><br><span class="line">题目数据保证总会存在一个数值和不超过 k 的矩形区域。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路：暴力解决，进行整改二维数组的搜索，使用前缀和 + 二分进行优化</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSumSubmatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length , n = matrix[<span class="number">0</span>].length;       </span><br><span class="line">        <span class="keyword">int</span> res = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)      <span class="comment">//枚举上边界</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; m; j++)  <span class="comment">//枚举下边界</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//计算前缀和</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; n; x++)</span><br><span class="line">                &#123;</span><br><span class="line">                    nums[x] += matrix[j][x];</span><br><span class="line">                &#125;</span><br><span class="line">                TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> TreeSet&lt;Integer&gt;();</span><br><span class="line">                set.add(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)</span><br><span class="line">                &#123;</span><br><span class="line">                    sum += num;</span><br><span class="line">                    Integer tmp = set.ceiling(sum - k); <span class="comment">//寻找最小的S[l] , 使 s[r] - s[l] &lt;= k 有最大值</span></span><br><span class="line">                    <span class="keyword">if</span>(tmp != <span class="keyword">null</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        res = Math.max(res , sum - tmp);    <span class="comment">//注意结果为 ： s[r] - s[l]</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    set.add(sum);       <span class="comment">//加入有序集合中</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>jz-54</title>
    <url>/post/a2323bb9.html</url>
    <content><![CDATA[<h1 id="剑指-Offer-54-二叉搜索树的第k大节点"><a href="#剑指-Offer-54-二叉搜索树的第k大节点" class="headerlink" title="剑指 Offer 54. 二叉搜索树的第k大节点"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">剑指 Offer 54. 二叉搜索树的第k大节点</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一棵二叉搜索树，请找出其中第k大的节点。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路： 二叉树中序遍历有序，从小到大排列</p>
<p>求第k大，应该倒过来进行寻找，右根左进行遍历</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        dfs(root , k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root , <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//第k大，右根左</span></span><br><span class="line">        dfs(root.right , k);</span><br><span class="line">        <span class="keyword">if</span>(++cnt == k)</span><br><span class="line">        &#123;</span><br><span class="line">            res = root.val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left , k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>jz-66</title>
    <url>/post/67110956.html</url>
    <content><![CDATA[<h1 id="剑指-Offer-66-构建乘积数组"><a href="#剑指-Offer-66-构建乘积数组" class="headerlink" title="剑指 Offer 66. 构建乘积数组"></a><a href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/">剑指 Offer 66. 构建乘积数组</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B[i] 的值是数组 A 中除了下标 i 以外的元素的积, 即 B[i]&#x3D;A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路：预先对数组进行处理，计算左边矩阵连乘结果，右边矩阵连乘结果，然后进行求解</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] constructArr(<span class="keyword">int</span>[] a) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.length;</span><br><span class="line">        <span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">                left[i] = a[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left[i] = left[i-<span class="number">1</span>] * a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == n- <span class="number">1</span>)</span><br><span class="line">                right[i] = a[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right[i] = right[i+<span class="number">1</span>] * a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算结果</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">                res[i] = right[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i == n-<span class="number">1</span>)</span><br><span class="line">                res[i] = left[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res[i] = left[i-<span class="number">1</span>] * right[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>优化内存空间的写法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] constructArr(<span class="keyword">int</span>[] a) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line">        b[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            b[i] = b[i - <span class="number">1</span>] * a[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = a.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            tmp *= a[i + <span class="number">1</span>];</span><br><span class="line">            b[i] *= tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>lc-368</title>
    <url>/post/c50d66de.html</url>
    <content><![CDATA[<h1 id="368-最大整除子集"><a href="#368-最大整除子集" class="headerlink" title="368. 最大整除子集"></a><a href="https://leetcode-cn.com/problems/largest-divisible-subset/">368. 最大整除子集</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给你一个由 无重复 正整数组成的集合 nums ，请你找出并返回其中最大的整除子集 answer ，子集中每一元素对 (answer[i], answer[j]) 都应当满足：</span><br><span class="line">answer[i] % answer[j] &#x3D;&#x3D; 0 ，或</span><br><span class="line">answer[j] % answer[i] &#x3D;&#x3D; 0</span><br><span class="line">如果存在多个有效解子集，返回其中任何一个均可。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路： 动态规划，计算出以nums[i]结尾的最大整除子集个数，然后倒序求结果，注意数组不一定有序，需要进行排序</p>
<p>状态转移方程：dp[i] = max(dp[i] , dp[j] + 1); (0 &lt;= j &lt; i)</p>
<p>base case: dp[i] = 1;(最小为1)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//coding</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">largestDivisibleSubset</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];      <span class="comment">//dp[i] : 以nums[i]为结尾的最大整除子集个数</span></span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span> , maxVal = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;      <span class="comment">//base case</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] % nums[j] == <span class="number">0</span>)</span><br><span class="line">                    dp[i] = Math.max(dp[i] , dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] &gt; maxLen)</span><br><span class="line">            &#123;</span><br><span class="line">                maxLen = dp[i];</span><br><span class="line">                maxVal = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(maxLen == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.add(nums[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//倒推获得最大子集</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(maxLen == dp[i] &amp;&amp; maxVal % nums[i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res.add(nums[i]);</span><br><span class="line">                maxLen--;</span><br><span class="line">                maxVal = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>lc-94</title>
    <url>/post/acd69900.html</url>
    <content><![CDATA[<h1 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个二叉树的根节点 root ，返回它的 中序 遍历。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>中序遍历，BFS套用模板</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span> || !stack.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(root != <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                stack.addLast(root);    <span class="comment">//压栈</span></span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pollLast();    <span class="comment">//弹栈</span></span><br><span class="line">            res.add(root.val);      <span class="comment">//添加元素</span></span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>lc-1011</title>
    <url>/post/9d341272.html</url>
    <content><![CDATA[<h1 id="1011-在-D-天内送达包裹的能力"><a href="#1011-在-D-天内送达包裹的能力" class="headerlink" title="1011. 在 D 天内送达包裹的能力"></a><a href="https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/">1011. 在 D 天内送达包裹的能力</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。</span><br><span class="line"></span><br><span class="line">传送带上的第 i 个包裹的重量为 weights[i]。每一天，我们都会按给出重量的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。</span><br><span class="line"></span><br><span class="line">返回能在 D 天内将传送带上的所有包裹送达的船的最低运载能力。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路：使用二分查找结果：首先确定船的最低运载能力，然后确定最大运载能力，然后在此之间进行查找</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shipWithinDays</span><span class="params">(<span class="keyword">int</span>[] weights, <span class="keyword">int</span> D)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = weights.length;</span><br><span class="line">        <span class="keyword">int</span> left = -<span class="number">1</span>, right = <span class="number">0</span>;       <span class="comment">//确定二分左右边界</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            left = Math.max(left , weights[i]);</span><br><span class="line">            right += weights[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)     <span class="comment">//二分</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(weights, mid , D)) <span class="comment">//满足最大运力</span></span><br><span class="line">            &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;   <span class="comment">//不满足最大运力</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span>[] weights , <span class="keyword">int</span> m , <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = weights.length, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(sum + weights[i] &lt;= m)   <span class="comment">//未达到最大运力，继续累加</span></span><br><span class="line">            &#123;</span><br><span class="line">                sum += weights[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//达到最大运力，更新</span></span><br><span class="line">                sum = weights[i];</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt &lt;= d;        <span class="comment">//该运力是否超过最大天数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>lc-377</title>
    <url>/post/4ca94a0e.html</url>
    <content><![CDATA[<h1 id="377-组合总和-Ⅳ"><a href="#377-组合总和-Ⅳ" class="headerlink" title="377. 组合总和 Ⅳ"></a><a href="https://leetcode-cn.com/problems/combination-sum-iv/">377. 组合总和 Ⅳ</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。</span><br><span class="line"></span><br><span class="line">题目数据保证答案符合 32 位整数范围。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/combination-sum-iv/solution/xi-wang-yong-yi-chong-gui-lu-gao-ding-bei-bao-wen-/">背包参考题解</a></p>
</blockquote>
<hr>
<blockquote>
<p>动态规划，考虑背包问题</p>
<p><em>dp</em>[<em>x</em>] 表示选取的元素之和等于 x<em>x</em> 的方案数，目标是求dp[target]。</p>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210424090633.png" alt="image-20210424090633543"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="comment">//dp[i] : 以i结尾的最大排列数</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;   <span class="comment">//不选取元素时，总和才为0 ， 方案为1  </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt;= num)</span><br><span class="line">                    dp[i] += dp[i - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>lc-897</title>
    <url>/post/de7f8861.html</url>
    <content><![CDATA[<h1 id="897-递增顺序搜索树"><a href="#897-递增顺序搜索树" class="headerlink" title="897. 递增顺序搜索树"></a><a href="https://leetcode-cn.com/problems/increasing-order-search-tree/">897. 递增顺序搜索树</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给你一棵二叉搜索树，请你 按中序遍历 将其重新排列为一棵递增顺序搜索树，使树中最左边的节点成为树的根节点，并且每个节点没有左子节点，只有一个右子节点。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路：中序遍历，在遍历的过程中对二叉搜素树进行修改，使用一个pre指针指向当前节点cur的左孩子，然后根据pre和cur的位置关系修改指针指向，更改指向后，将pre更新为cur，并清空其左子树</p>
<p>其他思路：迭代实现</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">increasingBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode dummy = <span class="keyword">new</span> TreeNode(-<span class="number">1</span>);</span><br><span class="line">        pre = dummy;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> dummy.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        pre.right = root;   <span class="comment">//更改指针指向</span></span><br><span class="line">        pre = root;         <span class="comment">//更新pre位置</span></span><br><span class="line">        pre.left = <span class="keyword">null</span>;    <span class="comment">//清空其左指针指向</span></span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>jz-16</title>
    <url>/post/28509f91.html</url>
    <content><![CDATA[<h1 id="剑指-Offer-16-数值的整数次方"><a href="#剑指-Offer-16-数值的整数次方" class="headerlink" title="剑指 Offer 16. 数值的整数次方"></a><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">剑指 Offer 16. 数值的整数次方</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。</span><br><span class="line"></span><br><span class="line">-100.0 &lt; x &lt; 100.0</span><br><span class="line">-231 &lt;&#x3D; n &lt;&#x3D; 2^31-1</span><br><span class="line">-104 &lt;&#x3D; xn &lt;&#x3D; 104</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路1：使用快速幂解法:   n可以写为二进制的形式，依次对二进制每一位做对应的乘法，可以实现通过迭代求解的效果；</p>
<p>注意边界条件： n取负的最大int值时，转换为正数，int类型放不下，需要使用long类型来存储；</p>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210430130024.png" alt="image-20210430130024113"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span> || x == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> t = n;</span><br><span class="line">        <span class="keyword">if</span>(t &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            x = <span class="number">1</span>/x;</span><br><span class="line">            t = -t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(t &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((t &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res *= x;</span><br><span class="line">            &#125;</span><br><span class="line">            x = x * x;</span><br><span class="line">            t &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路1：暴力循环，会超时</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//错误解法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//不考虑异常输入</span></span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                res *= x;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            n = -n;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                res *= x;</span><br><span class="line">            res = <span class="number">1</span> / res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>jz-13</title>
    <url>/post/583a6b1e.html</url>
    <content><![CDATA[<h1 id="剑指-Offer-13-机器人的运动范围"><a href="#剑指-Offer-13-机器人的运动范围" class="headerlink" title="剑指 Offer 13. 机器人的运动范围"></a><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">剑指 Offer 13. 机器人的运动范围</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7&#x3D;18。但它不能进入方格 [35, 38]，因为3+5+3+8&#x3D;19。请问该机器人能够到达多少个格子？</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路：使用回溯算法进行暴力搜索，注意不能对方格格子进行重复计数，需要使用标记数组visited对已经访问过的数组进行标记</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        dfs(<span class="number">0</span> , <span class="number">0</span> , m , n , k ,visited);</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i , <span class="keyword">int</span> j , <span class="keyword">int</span> m , <span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">boolean</span>[][] visited)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//剪枝</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= m || j &gt;= n || i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || visited[i][j] || getSum(i) + getSum(j) &gt; k)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">        visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        dfs(i + <span class="number">1</span> , j , m , n , k ,visited);</span><br><span class="line">        dfs(i , j + <span class="number">1</span>, m , n , k , visited);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += (num % <span class="number">10</span>);</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>jz-25</title>
    <url>/post/9a749de8.html</url>
    <content><![CDATA[<h1 id="剑指-Offer-25-合并两个排序的链表"><a href="#剑指-Offer-25-合并两个排序的链表" class="headerlink" title="剑指 Offer 25. 合并两个排序的链表"></a><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">剑指 Offer 25. 合并两个排序的链表</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>创建头结点，统一操作</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode cur = dummy;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt; l2.val)</span><br><span class="line">            &#123;</span><br><span class="line">                cur.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1 != <span class="keyword">null</span>)</span><br><span class="line">            cur.next = l1;</span><br><span class="line">        <span class="keyword">if</span>(l2 != <span class="keyword">null</span>)</span><br><span class="line">            cur.next = l2;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>jz-21</title>
    <url>/post/9d1959f1.html</url>
    <content><![CDATA[<h1 id="剑指-Offer-21-调整数组顺序使奇数位于偶数前面"><a href="#剑指-Offer-21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="剑指 Offer 21. 调整数组顺序使奇数位于偶数前面"></a><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路1 : 首尾双指针</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] exchange(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">//双指针</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((nums[i] &amp; <span class="number">1</span>) == <span class="number">0</span>)  <span class="comment">//偶数</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                nums[j] = tmp;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路2：快慢双指针</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] exchange(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((nums[fast] &amp; <span class="number">1</span>) == <span class="number">1</span>)     <span class="comment">//奇数</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = nums[fast];</span><br><span class="line">                nums[fast] = nums[slow];</span><br><span class="line">                nums[slow] = tmp;   <span class="comment">//奇数</span></span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>jz-26</title>
    <url>/post/37dcc52.html</url>
    <content><![CDATA[<h1 id="剑指-Offer-26-树的子结构"><a href="#剑指-Offer-26-树的子结构" class="headerlink" title="剑指 Offer 26. 树的子结构"></a><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">剑指 Offer 26. 树的子结构</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</span><br><span class="line"></span><br><span class="line">B是A的子结构， 即 A中有出现和B相同的结构和节点值。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路：递归</p>
<p>注意： 如果A为空，B为空，判定其非子结构，A 非空，B空，也非子结构；</p>
<p>需要双重递归：小递归函数判断B结构是否是A的一部分，大递归函数依次判断A的左右子树</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (A != <span class="keyword">null</span> &amp;&amp; B != <span class="keyword">null</span>) &amp;&amp; (isSub(A , B) || isSubStructure(A.left , B) || isSubStructure(A.right , B)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//B只要是A的一部分既可</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSub</span><span class="params">(TreeNode A, TreeNode B)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(B == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(A == <span class="keyword">null</span> || A.val != B.val)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSame(A.left , B.left) &amp;&amp; isSame(A.right , B.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>jz-27/28</title>
    <url>/post/975d3c5b.html</url>
    <content><![CDATA[<h1 id="剑指-Offer-27-二叉树的镜像"><a href="#剑指-Offer-27-二叉树的镜像" class="headerlink" title="剑指 Offer 27. 二叉树的镜像"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">剑指 Offer 27. 二叉树的镜像</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请完成一个函数，输入一个二叉树，该函数输出它的镜像。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>递归，先序遍历</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode tmp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = tmp;</span><br><span class="line">        mirrorTree(root.left);</span><br><span class="line">        mirrorTree(root.right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="剑指-Offer-28-对称的二叉树"><a href="#剑指-Offer-28-对称的二叉树" class="headerlink" title="剑指 Offer 28. 对称的二叉树"></a><a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/">剑指 Offer 28. 对称的二叉树</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</span><br><span class="line"></span><br><span class="line">例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>注意递归的思想</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(root.left , root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(TreeNode left , TreeNode right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span> || right == <span class="keyword">null</span> || left.val != right.val)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(left.left , right.right) &amp;&amp; dfs(left.right , right.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>jz-Offer32-I</title>
    <url>/post/d1273408.html</url>
    <content><![CDATA[<h1 id="剑指-Offer-32-I-从上到下打印二叉树"><a href="#剑指-Offer-32-I-从上到下打印二叉树" class="headerlink" title="剑指 Offer 32 - I. 从上到下打印二叉树"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">剑指 Offer 32 - I. 从上到下打印二叉树</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路：层序遍历，使用队列</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        queue.addLast(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode node = queue.pollFirst();</span><br><span class="line">            res.add(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[res.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length; i++)</span><br><span class="line">            nums[i] = res.get(i);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>jz-Offer55-I</title>
    <url>/post/f1037d51.html</url>
    <content><![CDATA[<h1 id="剑指-Offer-55-I-二叉树的深度"><a href="#剑指-Offer-55-I-二叉树的深度" class="headerlink" title="剑指 Offer 55 - I. 二叉树的深度"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/">剑指 Offer 55 - I. 二叉树的深度</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>递归：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = maxDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = maxDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left , right ) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在树上搜索最大的深度</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//回溯思想</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxdepth = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        dfs(root , <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> maxdepth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        depth++;</span><br><span class="line">        dfs(root.left , depth);</span><br><span class="line">        dfs(root.right , depth);</span><br><span class="line">        depth--;</span><br><span class="line">        maxdepth = Math.max(maxdepth , depth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>lc-137</title>
    <url>/post/2b415b64.html</url>
    <content><![CDATA[<h1 id="137-只出现一次的数字-II"><a href="#137-只出现一次的数字-II" class="headerlink" title="137. 只出现一次的数字 II"></a><a href="https://leetcode-cn.com/problems/single-number-ii/">137. 只出现一次的数字 II</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路：位运算： 考虑数组中每个元素的二进制位，对于出现3次的元素，各二进制位出现的次数都是3的倍数，可以统计各二进制位中1出现的次数，并对3取余，剩下的值就为只出现一次的数字对应二进制位的值</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> total = <span class="number">0</span>;      <span class="comment">//统计元素出现次数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(((num &gt;&gt; i) &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    total++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((total % <span class="number">3</span>) == <span class="number">1</span>)</span><br><span class="line">                res |= (<span class="number">1</span> &lt;&lt; i);    <span class="comment">// |= </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路2：使用HashMap统计数组中元素出现的次数，缺点：会消耗额外的空间</p>
</blockquote>
]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>lc-403</title>
    <url>/post/1ca0e55.html</url>
    <content><![CDATA[<h1 id="403-青蛙过河"><a href="#403-青蛙过河" class="headerlink" title="403.青蛙过河"></a>403.青蛙过河</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一只青蛙想要过河。 假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。 青蛙可以跳上石子，但是不可以跳入水中。</span><br><span class="line"></span><br><span class="line">给你石子的位置列表 stones（用单元格序号 升序 表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）。</span><br><span class="line"></span><br><span class="line">开始时， 青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格 1 跳至单元格 2 ）。</span><br><span class="line"></span><br><span class="line">如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1 个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路1：记忆化搜索，暴力搜索，模拟整个跳跃过程</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Boolean[][] memo;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer , Integer&gt; map;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canCross</span><span class="params">(<span class="keyword">int</span>[] stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = stones.length;</span><br><span class="line">        memo = <span class="keyword">new</span> Boolean[n][n];</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            map.put(stones[i] , i);</span><br><span class="line">        <span class="keyword">return</span> dfs(stones , <span class="number">0</span> , <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//记录状态： idx , lastStep作为状态参数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] stones , <span class="keyword">int</span> idx , <span class="keyword">int</span> lastStep)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(idx == stones.length - <span class="number">1</span>)    <span class="comment">//到达最后一个格子即为true</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(memo[idx][lastStep] != <span class="keyword">null</span>) <span class="comment">//不为空，说明中间有过计算，直接返回既可</span></span><br><span class="line">            <span class="keyword">return</span> memo[idx][lastStep];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> curStep = lastStep - <span class="number">1</span>; curStep &lt;= lastStep + <span class="number">1</span>; curStep++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(curStep &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//寻找下一步跳跃的位置是否存在</span></span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(stones[idx] + curStep))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> j = map.get(stones[idx] + curStep);</span><br><span class="line">                    <span class="comment">//递归,并记忆当前搜索结果</span></span><br><span class="line">                    <span class="keyword">if</span>(dfs(stones , j , curStep))       <span class="comment">//不成立时，保持当前位置为null</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">return</span> memo[idx][lastStep] = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[idx][lastStep] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>dp动态规划： </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canCross</span><span class="params">(<span class="keyword">int</span>[] stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = stones.length;</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//下标从0开始，第0个单元格可以跳1步，第j个单元格可以跳j+1步</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//从后往前遍历</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> k = stones[i] - stones[j];  <span class="comment">//需要跳跃距离</span></span><br><span class="line">                <span class="keyword">if</span>(k &gt; j + <span class="number">1</span>)   </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                dp[i][k] = dp[j][k-<span class="number">1</span>] || dp[j][k] || dp[j][k+<span class="number">1</span>];    <span class="comment">//状态转移方程,k的含义为步数，一定大于0</span></span><br><span class="line">                <span class="keyword">if</span>(i == n - <span class="number">1</span> &amp;&amp; dp[i][k])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





















]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>lc-633</title>
    <url>/post/296389f8.html</url>
    <content><![CDATA[<h1 id="633-平方数之和"><a href="#633-平方数之和" class="headerlink" title="633. 平方数之和"></a><a href="https://leetcode-cn.com/problems/sum-of-square-numbers/">633. 平方数之和</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 &#x3D; c 。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路：使用双指针</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judgeSquareSum</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span> , right = (<span class="keyword">int</span>)Math.sqrt(c);</span><br><span class="line">        <span class="comment">//双指针</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = left * left + right * right;</span><br><span class="line">            <span class="keyword">if</span>(sum == c)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; c)</span><br><span class="line">            &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>lc-938</title>
    <url>/post/b5ed174d.html</url>
    <content><![CDATA[<h1 id="938-二叉搜索树的范围和"><a href="#938-二叉搜索树的范围和" class="headerlink" title="938. 二叉搜索树的范围和"></a><a href="https://leetcode-cn.com/problems/range-sum-of-bst/">938. 二叉搜索树的范围和</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定二叉搜索树的根结点 root，返回值位于范围 [low, high] 之间的所有结点的值的和。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路1： DFS，2种写法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//写法1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rangeSumBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        dfs(root, low , high);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        dfs(root.left, low , high);</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt;= low &amp;&amp; root.val &lt;= high)</span><br><span class="line">            sum += root.val;</span><br><span class="line">        dfs(root.right, low , high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用二叉搜索树特性</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rangeSumBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; high)</span><br><span class="line">            <span class="keyword">return</span> rangeSumBST(root.left, low , high);</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; low)</span><br><span class="line">            <span class="keyword">return</span> rangeSumBST(root.right, low , high);</span><br><span class="line">        <span class="keyword">return</span> root.val + rangeSumBST(root.left, low , high) + rangeSumBST(root.right, low , high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>BFS写法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rangeSumBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        ArrayDeque&lt;TreeNode&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        stack.offerLast(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = stack.pollFirst();</span><br><span class="line">            <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(node.val &lt; low)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)</span><br><span class="line">                    stack.offerLast(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(node.val &gt; high)&#123;</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)</span><br><span class="line">                    stack.offerLast(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res += node.val;</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)		<span class="comment">//需要判断是否为空，否则会抛出异常</span></span><br><span class="line">                    stack.offerLast(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)</span><br><span class="line">                    stack.offerLast(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>jz-15</title>
    <url>/post/b159ce2b.html</url>
    <content><![CDATA[<h1 id="剑指-Offer-15-二进制中1的个数"><a href="#剑指-Offer-15-二进制中1的个数" class="headerlink" title="剑指 Offer 15. 二进制中1的个数"></a><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">剑指 Offer 15. 二进制中1的个数</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路1：最低位与运算，Java中无符号左移： &gt;&gt;&gt;</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((n &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">                cnt++;</span><br><span class="line">            n &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路2：利用 n&amp;(n-1)消除最低位1的规律，进行计数</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            n &amp;= (n-<span class="number">1</span>); <span class="comment">//消除最低位1</span></span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>jz-40</title>
    <url>/post/bc44cee1.html</url>
    <content><![CDATA[<h1 id="剑指-Offer-40-最小的k个数"><a href="#剑指-Offer-40-最小的k个数" class="headerlink" title="剑指 Offer 40. 最小的k个数"></a><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">剑指 Offer 40. 最小的k个数</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路：可以使用快排，或者最大堆（优先队列）的方式进行实现</p>
<p>1）注意边界条件：k == 0，数组为空的特殊情况</p>
<p>2）考虑带不带等号</p>
<p>3)优先队列底层实现原理：使用数组实现，父节点和左右子节点的位置关系</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1 , Integer o2)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2 - o1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(queue.size() &gt;= k)       <span class="comment">//这里一定要带等号！！</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i] &lt; queue.peek())</span><br><span class="line">                &#123;</span><br><span class="line">                    queue.poll();</span><br><span class="line">                    queue.offer(arr[i]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                queue.offer(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">            res[i] = queue.poll();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span> || n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2 - o1;         <span class="comment">//大根堆</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(queue.size() &lt; k)</span><br><span class="line">            &#123;</span><br><span class="line">                queue.offer(arr[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(queue.peek() &gt; arr[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    queue.poll();</span><br><span class="line">                    queue.offer(arr[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">            res[i] = queue.poll();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>lc-146</title>
    <url>/post/1307fd35.html</url>
    <content><![CDATA[<h1 id="146-LRU-缓存机制"><a href="#146-LRU-缓存机制" class="headerlink" title="146. LRU 缓存机制"></a><a href="https://leetcode-cn.com/problems/lru-cache/">146. LRU 缓存机制</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制 。</span><br><span class="line">实现 LRUCache 类：</span><br><span class="line"></span><br><span class="line">LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存</span><br><span class="line">int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。</span><br><span class="line">void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</span><br><span class="line"></span><br><span class="line">进阶：你是否可以在 O(1) 时间复杂度内完成这两种操作？</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>LinkedHashMap实现方式：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">Integer</span>, <span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(capacity , <span class="number">0.75F</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getOrDefault(key , -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.put(key ,value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;Integer , Integer&gt; eldest)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; capacity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>自己定义类实现方式：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRU</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Node&gt; map;</span><br><span class="line">    <span class="keyword">private</span> Doublelist doublelist;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRU</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;(capacity);</span><br><span class="line">        doublelist = <span class="keyword">new</span> Doublelist();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(key))</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Node node = map.get(key);</span><br><span class="line">            doublelist.moveToFirst(node);</span><br><span class="line">            <span class="keyword">return</span> node.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key , <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(key , value);</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(key))</span><br><span class="line">        &#123;</span><br><span class="line">            doublelist.remove(map.get(key));</span><br><span class="line">            doublelist.addFirst(node);</span><br><span class="line">            map.put(key , node);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(doublelist.size() == capacity)&#123;</span><br><span class="line">                map.remove(doublelist.removeLast().key);</span><br><span class="line">            &#125;</span><br><span class="line">            doublelist.addFirst(node);</span><br><span class="line">            map.put(key, node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Doublelist</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="keyword">private</span> Node tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Doublelist</span><span class="params">()</span></span>&#123;</span><br><span class="line">        head = <span class="keyword">new</span> Node();</span><br><span class="line">        tail = <span class="keyword">new</span> Node();</span><br><span class="line">        head.pre = <span class="keyword">null</span>;</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.pre = head;</span><br><span class="line">        tail.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(Node node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        node.pre = head;</span><br><span class="line">        head.next.pre = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Node node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        node.pre.next = node.next;</span><br><span class="line">        node.next.pre = node.pre;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">removeLast</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node node = tail.pre;</span><br><span class="line">        tail.pre = tail.pre.pre;</span><br><span class="line">        tail.pre.next = tail;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveToFirst</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        remove(node);</span><br><span class="line">        addFirst(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> key , val;</span><br><span class="line">    <span class="keyword">public</span> Node next , pre;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> k , <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = k;</span><br><span class="line">        <span class="keyword">this</span>.val = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>lc-554</title>
    <url>/post/e31b0584.html</url>
    <content><![CDATA[<h1 id="554-砖墙"><a href="#554-砖墙" class="headerlink" title="554. 砖墙"></a><a href="https://leetcode-cn.com/problems/brick-wall/">554. 砖墙</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">你的面前有一堵矩形的、由 n 行砖块组成的砖墙。这些砖块高度相同（也就是一个单位高）但是宽度不同。每一行砖块的宽度之和应该相等。</span><br><span class="line"></span><br><span class="line">你现在要画一条 自顶向下 的、穿过 最少 砖块的垂线。如果你画的线只是从砖块的边缘经过，就不算穿过这块砖。你不能沿着墙的两个垂直边缘之一画线，这样显然是没有穿过一块砖的。</span><br><span class="line"></span><br><span class="line">给你一个二维数组 wall ，该数组包含这堵墙的相关信息。其中，wall[i] 是一个代表从左至右每块砖的宽度的数组。你需要找出怎样画才能使这条线 穿过的砖块数量最少 ，并且返回 穿过的砖块数量 。</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210502174036.png" alt="image-20210502174036773"></p>
<hr>
<blockquote>
<p>思路 :  正难则反，题目要求穿过的砖块最少，等效于求穿过的间隙最多，可以使用HashMap记录每个间隙出现的次数，最后统计所有行中哪些间隙出现地最多，使用总行数-间隙出现次数，即为答案</p>
<p>注意：左右边界不能算</p>
</blockquote>
<blockquote>
<p>Map.Entry&lt;K , V&gt; API :</p>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210502174309.png" alt="image-20210502174309459"></p>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210502175034.png" alt="image-20210502175034289"></p>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210502174329.png" alt="image-20210502174329161"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leastBricks</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; wall)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(List&lt;Integer&gt; a : wall)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> n = a.size() , sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)      <span class="comment">//去除第一个和最后一个</span></span><br><span class="line">            &#123;</span><br><span class="line">                sum += a.get(i);</span><br><span class="line">                map.put(sum , map.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//寻找穿过的最大间隙数</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer , Integer&gt; entry : map.entrySet())</span><br><span class="line">        &#123;</span><br><span class="line">            cnt = Math.max(cnt, entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> wall.size() - cnt;       <span class="comment">//返回穿过的砖的数量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leastBricks</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; wall)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer , Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="comment">//统计每列穿过间隙数</span></span><br><span class="line">        <span class="keyword">for</span>(List&lt;Integer&gt; width : wall)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> n = width.size() , sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += width.get(i);</span><br><span class="line">                map.put(sum ,map.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找出最大间隙数</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer , Integer&gt; entry : map.entrySet())</span><br><span class="line">        &#123;</span><br><span class="line">            max = Math.max(max , entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> wall.size() - max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>lc-690</title>
    <url>/post/4a8530c8.html</url>
    <content><![CDATA[<h1 id="690-员工的重要性"><a href="#690-员工的重要性" class="headerlink" title="690. 员工的重要性"></a><a href="https://leetcode-cn.com/problems/employee-importance/">690. 员工的重要性</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个保存员工信息的数据结构，它包含了员工 唯一的 id ，重要度 和 直系下属的 id 。</span><br><span class="line"></span><br><span class="line">比如，员工 1 是员工 2 的领导，员工 2 是员工 3 的领导。他们相应的重要度为 15 , 10 , 5 。那么员工 1 的数据结构是 [1, 15, [2]] ，员工 2的 数据结构是 [2, 10, [3]] ，员工 3 的数据结构是 [3, 5, []] 。注意虽然员工 3 也是员工 1 的一个下属，但是由于 并不是直系 下属，因此没有体现在员工 1 的数据结构中。</span><br><span class="line"></span><br><span class="line">现在输入一个公司的所有员工信息，以及单个员工 id ，返回这个员工和他所有下属的重要度之和。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路：使用DFS，对初始的数据结构进行预处理，将他们存在Map当中，然后进行搜索</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Employee&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getImportance</span><span class="params">(List&lt;Employee&gt; employees, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Employee e : employees)</span><br><span class="line">            map.put(e.id , e);      <span class="comment">//建立映射关系</span></span><br><span class="line">        <span class="keyword">return</span> dfs(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Employee e = map.get(id);</span><br><span class="line">        <span class="keyword">int</span> res = e.importance;</span><br><span class="line">        List&lt;Integer&gt; list = e.subordinates;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : list)</span><br><span class="line">        &#123;</span><br><span class="line">            res += dfs(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>BFS广度优先遍历写法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getImportance</span><span class="params">(List&lt;Employee&gt; employees, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer , Employee&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Employee e : employees)</span><br><span class="line">            map.put(e.id , e);</span><br><span class="line">        Deque&lt;Employee&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        queue.offerLast(map.get(id)); </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            Employee e = queue.pollFirst();</span><br><span class="line">            res += e.importance;</span><br><span class="line">            List&lt;Integer&gt; tmp = e.subordinates;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i : tmp)</span><br><span class="line">            &#123;</span><br><span class="line">                queue.addLast(map.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>jz-18</title>
    <url>/post/cfe8b296.html</url>
    <content><![CDATA[<h1 id="剑指-Offer-18-删除链表的节点"><a href="#剑指-Offer-18-删除链表的节点" class="headerlink" title="剑指 Offer 18. 删除链表的节点"></a><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/">剑指 Offer 18. 删除链表的节点</a></h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</span><br><span class="line"></span><br><span class="line">返回删除后的链表的头节点。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路：普通链表操作，注意考虑结点是否为null的情况</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteNode</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode pre = dummy , cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span> &amp;&amp; cur.val != val)</span><br><span class="line">        &#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur != <span class="keyword">null</span>)</span><br><span class="line">            pre.next = cur.next;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>jz-31</title>
    <url>/post/840268b0.html</url>
    <content><![CDATA[<h1 id="剑指-Offer-31-栈的压入、弹出序列"><a href="#剑指-Offer-31-栈的压入、弹出序列" class="headerlink" title="剑指 Offer 31. 栈的压入、弹出序列"></a><a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/">剑指 Offer 31. 栈的压入、弹出序列</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 &#123;1,2,3,4,5&#125; 是某栈的压栈序列，序列 &#123;4,5,3,2,1&#125; 是该压栈序列对应的一个弹出序列，但 &#123;4,3,5,1,2&#125; 就不可能是该压栈序列的弹出序列。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路：使用辅助栈，模拟弹出弹出的过程</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = pushed.length;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            stack.addLast(pushed[i]);</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peekLast() == popped[idx])</span><br><span class="line">            &#123;</span><br><span class="line">                stack.pollLast();</span><br><span class="line">                idx++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>lc-1473</title>
    <url>/post/22697c04.html</url>
    <content><![CDATA[<h1 id="1473-粉刷房子-III"><a href="#1473-粉刷房子-III" class="headerlink" title="1473. 粉刷房子 III"></a><a href="https://leetcode-cn.com/problems/paint-house-iii/">1473. 粉刷房子 III</a></h1><p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210506151459.png" alt="image-20210506151459194"></p>
<hr>
<blockquote>
<p>思路：动态规划</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INFTY = Integer.MAX_VALUE / <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="keyword">int</span>[] houses, <span class="keyword">int</span>[][] cost, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将颜色调整为从0开始的编号，没有被涂色标记为-1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            --houses[i];</span><br><span class="line">        <span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n][target];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                Arrays.fill(dp[i][j] , INFTY);</span><br><span class="line">        <span class="comment">//填表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(houses[i] != -<span class="number">1</span> &amp;&amp; houses[i] != j)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; target; k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j0 = <span class="number">0</span>; j0 &lt; n; j0++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(j == j0)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                                <span class="keyword">if</span>(k == <span class="number">0</span>)</span><br><span class="line">                                    dp[i][j][k] = <span class="number">0</span>;</span><br><span class="line">                            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                                dp[i][j][k] = Math.min(dp[i][j][k] ,dp[i-<span class="number">1</span>][j][k]);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; k &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                            dp[i][j][k] = Math.min(dp[i][j][k] , dp[i-<span class="number">1</span>][j0][k-<span class="number">1</span>]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(dp[i][j][k] != INFTY &amp;&amp; houses[i] == -<span class="number">1</span>)</span><br><span class="line">                        dp[i][j][k] += cost[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = INFTY;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            ans = Math.min(ans , dp[m-<span class="number">1</span>][j][target - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> ans == INFTY ? -<span class="number">1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>lc-1486</title>
    <url>/post/d59b9444.html</url>
    <content><![CDATA[<h1 id="1486-数组异或操作"><a href="#1486-数组异或操作" class="headerlink" title="1486. 数组异或操作"></a><a href="https://leetcode-cn.com/problems/xor-operation-in-an-array/">1486. 数组异或操作</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给你两个整数，n 和 start 。</span><br><span class="line"></span><br><span class="line">数组 nums 定义为：nums[i] &#x3D; start + 2*i（下标从 0 开始）且 n &#x3D;&#x3D; nums.length 。</span><br><span class="line"></span><br><span class="line">请返回 nums 中所有元素按位异或（XOR）后得到的结果。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路： 模拟异或计算过程</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">xorOperation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[i] = start + <span class="number">2</span> * i;</span><br><span class="line">            res ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>考虑数学规律：</p>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210507194356.png" alt="image-20210507194356130"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">xorOperation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = start &gt;&gt; <span class="number">1</span>, e = n &amp; start &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ret = sumXor(s - <span class="number">1</span>) ^ sumXor(s + n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ret &lt;&lt; <span class="number">1</span> | e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumXor</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x % <span class="number">4</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x % <span class="number">4</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x % <span class="number">4</span> == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> x + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>lc-1720</title>
    <url>/post/c45167a2.html</url>
    <content><![CDATA[<h1 id="1720-解码异或后的数组"><a href="#1720-解码异或后的数组" class="headerlink" title="1720. 解码异或后的数组"></a><a href="https://leetcode-cn.com/problems/decode-xored-array/">1720. 解码异或后的数组</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">未知 整数数组 arr 由 n 个非负整数组成。</span><br><span class="line"></span><br><span class="line">经编码后变为长度为 n - 1 的另一个整数数组 encoded ，其中 encoded[i] &#x3D; arr[i] XOR arr[i + 1] 。例如，arr &#x3D; [1,0,2,1] 经编码后得到 encoded &#x3D; [1,2,3] 。</span><br><span class="line"></span><br><span class="line">给你编码后的数组 encoded 和原数组 arr 的第一个元素 first（arr[0]）。</span><br><span class="line"></span><br><span class="line">请解码返回原数组 arr 。可以证明答案存在并且是唯一的。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路：异或运算的性质：</p>
<ul>
<li>异或运算满足交换律和结合律</li>
<li>任意整数和自身进行异或运算结果为0</li>
<li>任意整数和0进行异或运算结果都等于自身</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] decode(<span class="keyword">int</span>[] encoded, <span class="keyword">int</span> first) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = encoded.length;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        res[<span class="number">0</span>] = first;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res[i] = encoded[i-<span class="number">1</span>] ^ first;</span><br><span class="line">            first = res[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>lc-1423</title>
    <url>/post/5f1e8841.html</url>
    <content><![CDATA[<h1 id="1423-可获得的最大点数"><a href="#1423-可获得的最大点数" class="headerlink" title="1423. 可获得的最大点数"></a><a href="https://leetcode-cn.com/problems/maximum-points-you-can-obtain-from-cards/">1423. 可获得的最大点数</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">几张卡牌 排成一行，每张卡牌都有一个对应的点数。点数由整数数组 cardPoints 给出。</span><br><span class="line"></span><br><span class="line">每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 k 张卡牌。</span><br><span class="line"></span><br><span class="line">你的点数就是你拿到手中的所有卡牌的点数之和。</span><br><span class="line"></span><br><span class="line">给你一个整数数组 cardPoints 和整数 k，请你返回可以获得的最大点数。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路：正难则反，滑动窗口</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxScore</span><span class="params">(<span class="keyword">int</span>[] cardPoints, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//正难则反</span></span><br><span class="line">        <span class="keyword">int</span> n = cardPoints.length , len = n - k;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            sum += cardPoints[i];</span><br><span class="line">        <span class="keyword">int</span> win = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            win += cardPoints[i];</span><br><span class="line">        <span class="keyword">int</span> min = win;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            win = win - cardPoints[i-len] + cardPoints[i];      <span class="comment">//更新滑动窗口</span></span><br><span class="line">            min = Math.min(min , win);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum - min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>lc-1734</title>
    <url>/post/da2792fa.html</url>
    <content><![CDATA[<h1 id="1734-解码异或后的排列"><a href="#1734-解码异或后的排列" class="headerlink" title="1734. 解码异或后的排列"></a><a href="https://leetcode-cn.com/problems/decode-xored-permutation/">1734. 解码异或后的排列</a></h1><p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210511113416.png" alt="image-20210511113347577"></p>
<hr>
<blockquote>
<p>思路：数组为前n个正整数的排列，则整个数组和的异或结果可以求出来，</p>
<p>encode数组从第一个元素开始间隔一个进行连续异或操作，可以求出原数组从0-n-1的异或结果</p>
<p>根据异或性质求出原数组最后一个元素值，既可完成求解</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] decode(<span class="keyword">int</span>[] encoded) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = encoded.length , n = len + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)     <span class="comment">//数组整体异或</span></span><br><span class="line">            total ^= i;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;   <span class="comment">//p[0]-p[n-1]异或</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i += <span class="number">2</span>)</span><br><span class="line">            tmp ^= encoded[i];</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        res[n-<span class="number">1</span>] = total ^ tmp;         <span class="comment">//计算出最后一个元素</span></span><br><span class="line">        <span class="comment">//计算原数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            res[i] = encoded[i] ^ res[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>lc-1723</title>
    <url>/post/5d583618.html</url>
    <content><![CDATA[<h1 id="1723-完成所有工作的最短时间"><a href="#1723-完成所有工作的最短时间" class="headerlink" title="1723. 完成所有工作的最短时间"></a><a href="https://leetcode-cn.com/problems/find-minimum-time-to-finish-all-jobs/">1723. 完成所有工作的最短时间</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给你一个整数数组 jobs ，其中 jobs[i] 是完成第 i 项工作要花费的时间。</span><br><span class="line"></span><br><span class="line">请你将这些工作分配给 k 位工人。所有工作都应该分配给工人，且每项工作只能分配给一位工人。工人的 工作时间 是完成分配给他们的所有工作花费时间的总和。请你设计一套最佳的工作分配方案，使工人的 最大工作时间 得以 最小化 。</span><br><span class="line"></span><br><span class="line">返回分配方案中尽可能 最小 的 最大工作时间 。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路1 ： 回溯 + 剪枝</p>
<p>回溯模板：</p>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210508154143.png" alt="image-20210508154143695"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTimeRequired</span><span class="params">(<span class="keyword">int</span>[] jobs, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        backtrack(jobs , <span class="number">0</span> , <span class="keyword">new</span> <span class="keyword">int</span>[k] , <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] jobs , <span class="keyword">int</span> i , <span class="keyword">int</span>[] workers , <span class="keyword">int</span> limit)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= jobs.length)</span><br><span class="line">        &#123;</span><br><span class="line">            res = Math.min(res , limit);        <span class="comment">//选择最小工作时间</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();     <span class="comment">//去重</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; workers.length; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.add(workers[j]))    <span class="comment">//当前层出现重复元素</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(workers[j] + jobs[i] &gt;= res)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            workers[j] += jobs[i];</span><br><span class="line">            backtrack(jobs , i + <span class="number">1</span> , workers , Math.max(workers[j] , limit));</span><br><span class="line">            workers[j] -= jobs[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路2 ： 二分 + 回溯 + 剪枝</p>
<p>最短分配时间为job中最大值，最长分配时间为job数组和（分配给一个人），在上边界和下边界之间进行二分查找；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTimeRequired</span><span class="params">(<span class="keyword">int</span>[] jobs, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(jobs);</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = jobs.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = jobs[low];</span><br><span class="line">            jobs[low] = jobs[high];</span><br><span class="line">            jobs[high] = tmp;</span><br><span class="line">            low++;</span><br><span class="line">            high--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = jobs[<span class="number">0</span>] , r = Arrays.stream(jobs).sum();</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(jobs , k , mid))&#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span>[] jobs , <span class="keyword">int</span> k , <span class="keyword">int</span> limit)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] workloads = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">return</span> backtrack(jobs , workloads , <span class="number">0</span> , limit);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] jobs , <span class="keyword">int</span>[] workloads , <span class="keyword">int</span> i , <span class="keyword">int</span> limit)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= jobs.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> cur = jobs[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; workloads.length; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(workloads[j] + cur &lt;= limit)&#123;</span><br><span class="line">                workloads[j] += cur;</span><br><span class="line">                <span class="keyword">if</span>(backtrack(jobs , workloads , i + <span class="number">1</span>, limit))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                workloads[j] -= cur;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(workloads[j] == <span class="number">0</span> || workloads[j] + cur == limit)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





















]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>lc-7</title>
    <url>/post/82b21d3e.html</url>
    <content><![CDATA[<h1 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7. 整数反转"></a><a href="https://leetcode-cn.com/problems/reverse-integer/">7. 整数反转</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。</span><br><span class="line"></span><br><span class="line">如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。</span><br><span class="line"></span><br><span class="line">假设环境不允许存储 64 位整数（有符号或无符号）。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路：考虑整数溢出的问题，分析出什么时候会溢出，在每次循环中取最低位累加到最高位，循环终止条件：x == 0(可以处理正数或者负数的情况)</p>
<p>int 范围： 2^-31 ~ 2^31 - 1</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(res &gt; <span class="number">214748364</span> || (res == <span class="number">214748364</span> &amp;&amp; (x % <span class="number">10</span>) &gt; <span class="number">7</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(res &lt; -<span class="number">214748364</span> || (res == -<span class="number">214748364</span> &amp;&amp; (x % <span class="number">10</span>) &lt; -<span class="number">8</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            res = res * <span class="number">10</span> + (x % <span class="number">10</span>);</span><br><span class="line">            x = x / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(res &gt; Integer.MAX_VALUE / <span class="number">10</span> || res &lt; Integer.MIN_VALUE / <span class="number">10</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            res = res * <span class="number">10</span> + (x % <span class="number">10</span>);</span><br><span class="line">            x = x / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>lc-872</title>
    <url>/post/30965160.html</url>
    <content><![CDATA[<h1 id="872-叶子相似的树"><a href="#872-叶子相似的树" class="headerlink" title="872. 叶子相似的树"></a><a href="https://leetcode-cn.com/problems/leaf-similar-trees/">872. 叶子相似的树</a></h1><p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210510224444.png" alt="image-20210510224443960"></p>
<hr>
<blockquote>
<p>思路：中序遍历，获取叶子结点值，存在数组中，然后进行比较，比较是否相同</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">leafSimilar</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; leaf1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; leaf2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        recur(root1, leaf1);</span><br><span class="line">        recur(root2, leaf2);</span><br><span class="line">        <span class="keyword">if</span>(leaf1.size() != leaf2.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; leaf1.size(); i++)</span><br><span class="line">            <span class="keyword">if</span>(leaf1.get(i) != leaf2.get(i))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recur</span><span class="params">(TreeNode root , List&lt;Integer&gt; leaf)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//中序遍历</span></span><br><span class="line">        recur(root.left ,leaf);</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)     <span class="comment">//只有是叶子结点才进行添加</span></span><br><span class="line">            leaf.add(root.val);</span><br><span class="line">        recur(root.right , leaf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>















]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>jz57-II</title>
    <url>/post/200cd57.html</url>
    <content><![CDATA[<h1 id="剑指-Offer-57-II-和为s的连续正数序列"><a href="#剑指-Offer-57-II-和为s的连续正数序列" class="headerlink" title="剑指 Offer 57 - II. 和为s的连续正数序列"></a><a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/">剑指 Offer 57 - II. 和为s的连续正数序列</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</span><br><span class="line"></span><br><span class="line">序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路：滑动窗口</p>
<p>注意：这里滑动窗口为左闭右开区间，窗口的初始位置：1（正整数序列），窗口只能向右滑动，不能向左滑动；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] findContinuousSequence(<span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;   <span class="comment">//左边界</span></span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">1</span>;  <span class="comment">//右边界</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;    <span class="comment">//窗口和</span></span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= target/<span class="number">2</span>)     <span class="comment">//最小值不能超过target一半</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(sum &lt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += right;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                sum -= left;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[right - left];     <span class="comment">//左闭右开区间，所以数组长度为right - left</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = left; k &lt; right; k++)</span><br><span class="line">                    nums[k - left] = k;</span><br><span class="line">                res.add(nums);</span><br><span class="line">                <span class="comment">//再次滑动窗口 </span></span><br><span class="line">                sum -= left;</span><br><span class="line">                left++;         </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[res.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
        <category>滑动窗口</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>jz59-I</title>
    <url>/post/68aa00a6.html</url>
    <content><![CDATA[<h1 id="剑指-Offer-59-I-滑动窗口的最大值"><a href="#剑指-Offer-59-I-滑动窗口的最大值" class="headerlink" title="剑指 Offer 59 - I. 滑动窗口的最大值"></a><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/">剑指 Offer 59 - I. 滑动窗口的最大值</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路1：滑动窗口，定义大顶堆，每次取堆顶元素放入其中</p>
<p>时间复杂度：O(nlogn)</p>
<p>空间复杂度：O(n)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || k &gt; n)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//定义大顶堆</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2 - o1;     <span class="comment">//大顶堆</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">            queue.offer(nums[i]);</span><br><span class="line">        res[<span class="number">0</span>] = queue.peek();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> lastnum = nums[i - k] , newnum = nums[i];</span><br><span class="line">            queue.remove(lastnum);</span><br><span class="line">            queue.offer(newnum);</span><br><span class="line">            res[i - k + <span class="number">1</span>] = queue.peek();      <span class="comment">//新窗口的最大值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>更好的解法：使用双端队列；维护一个单调队列</p>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210516213405.png" alt="image-20210516213405269"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || n &lt; k)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        Deque&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!queue.isEmpty() &amp;&amp; queue.peekLast() &lt; nums[i])</span><br><span class="line">                queue.pollLast();</span><br><span class="line">            queue.addLast(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        res[<span class="number">0</span>] = queue.peekFirst();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(queue.peekFirst() == nums[i-k])      <span class="comment">//特殊情况排除</span></span><br><span class="line">                queue.pollFirst();</span><br><span class="line">            <span class="keyword">while</span>(!queue.isEmpty() &amp;&amp; queue.peekLast() &lt; nums[i])</span><br><span class="line">                queue.pollLast();</span><br><span class="line">            queue.addLast(nums[i]);</span><br><span class="line">            res[i-k+<span class="number">1</span>] = queue.peekFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
        <category>优先队列</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title>jz-17</title>
    <url>/post/5f57af07.html</url>
    <content><![CDATA[<h1 id="剑指-Offer-17-打印从1到最大的n位数"><a href="#剑指-Offer-17-打印从1到最大的n位数" class="headerlink" title="剑指 Offer 17. 打印从1到最大的n位数"></a><a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/">剑指 Offer 17. 打印从1到最大的n位数</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路：普通计算，考虑大数问题（数字过大溢出怎么处理）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] printNumbers(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span> cap = (<span class="keyword">int</span>)Math.pow(<span class="number">10</span>, n) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[cap];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cap; i++)</span><br><span class="line">            res[i-<span class="number">1</span>] = i;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>jz-20</title>
    <url>/post/ea1e6967.html</url>
    <content><![CDATA[<h1 id="剑指-Offer-20-表示数值的字符串"><a href="#剑指-Offer-20-表示数值的字符串" class="headerlink" title="剑指 Offer 20. 表示数值的字符串"></a><a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/">剑指 Offer 20. 表示数值的字符串</a></h1><p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210511212242.png" alt="image-20210511212242303"></p>
<hr>
<blockquote>
<p>思路：有限自动状态机：</p>
<p>一个自动机，总能够回答某种形式的「<strong>对于给定的输入字符串 S，判断其是否满足条件 P</strong>」的问题。在本题中，条件 P 即为「构成合法的表示数值的字符串」。</p>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210511212305.png" alt="image-20210511212305648"></p>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210511215704.png" alt="image-20210511215704166"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Map[] states = &#123;</span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;&gt;()&#123;&#123;put(<span class="string">&#x27; &#x27;</span> , <span class="number">0</span>); put(<span class="string">&#x27;s&#x27;</span> , <span class="number">1</span>); put(<span class="string">&#x27;d&#x27;</span> , <span class="number">2</span>); put(<span class="string">&#x27;.&#x27;</span>,<span class="number">4</span>);&#125;&#125;,   <span class="comment">//0</span></span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;&gt;()&#123;&#123;put(<span class="string">&#x27;d&#x27;</span>,<span class="number">2</span>); put(<span class="string">&#x27;.&#x27;</span>,<span class="number">4</span>);&#125;&#125;,     <span class="comment">//1</span></span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;&gt;()&#123;&#123;put(<span class="string">&#x27;d&#x27;</span>,<span class="number">2</span>);put(<span class="string">&#x27;.&#x27;</span>,<span class="number">3</span>);put(<span class="string">&#x27;e&#x27;</span>,<span class="number">5</span>);put(<span class="string">&#x27; &#x27;</span>,<span class="number">8</span>);&#125;&#125;,    <span class="comment">//2</span></span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;&gt;()&#123;&#123;put(<span class="string">&#x27;d&#x27;</span>,<span class="number">3</span>);put(<span class="string">&#x27;e&#x27;</span>,<span class="number">5</span>);put(<span class="string">&#x27; &#x27;</span>, <span class="number">8</span>);&#125;&#125;,      <span class="comment">//3</span></span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;&gt;()&#123;&#123;put(<span class="string">&#x27;d&#x27;</span>,<span class="number">3</span>);&#125;&#125;,    <span class="comment">//4</span></span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;&gt;()&#123;&#123;put(<span class="string">&#x27;s&#x27;</span>,<span class="number">6</span>);put(<span class="string">&#x27;d&#x27;</span>,<span class="number">7</span>);&#125;&#125;,      <span class="comment">//5</span></span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;&gt;()&#123;&#123;put(<span class="string">&#x27;d&#x27;</span> , <span class="number">7</span>);&#125;&#125;,       <span class="comment">//6</span></span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;&gt;()&#123;&#123;put(<span class="string">&#x27;d&#x27;</span>,<span class="number">7</span>); put(<span class="string">&#x27; &#x27;</span> , <span class="number">8</span>);&#125;&#125;,   <span class="comment">//7</span></span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;&gt;()&#123;&#123;put(<span class="string">&#x27; &#x27;</span> , <span class="number">8</span>);&#125;&#125;        <span class="comment">//8</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> t;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : s.toCharArray())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">                t = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">                t = <span class="string">&#x27;s&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;e&#x27;</span> || c == <span class="string">&#x27;E&#x27;</span>)</span><br><span class="line">                t = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;.&#x27;</span> || c == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                t = c;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                t = <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(!states[p].containsKey(t))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            p = (<span class="keyword">int</span>)states[p].get(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p == <span class="number">2</span> || p == <span class="number">3</span> || p == <span class="number">7</span> || p == <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="FSA（有限状态自动机）"><a href="#FSA（有限状态自动机）" class="headerlink" title="FSA（有限状态自动机）"></a>FSA（有限状态自动机）</h2><p>参考视频：<a href="https://www.youtube.com/watch?v=jgQto5Yht7Y">https://www.youtube.com/watch?v=jgQto5Yht7Y</a></p>
<p>有限状态自动机（FSA） ：一种计算模型，表示有限个状态以及在这些状态之间的转移行为，最终判断一系列行为是否符合可接受要求；</p>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210511212539.png" alt="image-20210511212539665"></p>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210511212756.png" alt="image-20210511212756617"></p>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210511212918.png" alt="image-20210511212917938"></p>
<p>有限状态自动机的状态转移图是一个有向图：</p>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210511213048.png" alt="image-20210511213048325"></p>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210511213121.png" alt="image-20210511213120933"></p>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210511213419.png" alt="image-20210511213419095"></p>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210511214038.png" alt="image-20210511214038161"></p>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210511214320.png" alt="image-20210511214320298"></p>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210511214608.png" alt="image-20210511214608761"></p>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210511214834.png" alt="image-20210511214834497"></p>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210511214959.png" alt="image-20210511214959538"></p>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210511215009.png" alt="image-20210511215009589"></p>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210511215118.png" alt="image-20210511215118174"></p>
]]></content>
      <categories>
        <category>剑指Offer</category>
        <category>有限状态自动机</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
        <tag>有限状态自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>jz-29</title>
    <url>/post/93c2d1c3.html</url>
    <content><![CDATA[<h1 id="剑指-Offer-29-顺时针打印矩阵"><a href="#剑指-Offer-29-顺时针打印矩阵" class="headerlink" title="剑指 Offer 29. 顺时针打印矩阵"></a><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">剑指 Offer 29. 顺时针打印矩阵</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路： 设置左右上下标记位，每次循环一圈，将对应标志位进行修改；</p>
<p>注意：每次修改标志位后判断是否应该跳出该无限循环（已打印完情况判断）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] spiralOrder(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length ;        </span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[m * n];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span> , up = <span class="number">0</span>, down = m -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = left; j &lt;= right; j++)  <span class="comment">//left --&gt; right</span></span><br><span class="line">                res[k++] = matrix[up][j];</span><br><span class="line">            <span class="keyword">if</span>(++up &gt; down)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = up; i &lt;= down; i++)     <span class="comment">//up --&gt; bottom</span></span><br><span class="line">                res[k++] = matrix[i][right];    </span><br><span class="line">            <span class="keyword">if</span>(--right &lt; left)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = right; j &gt;= left; j--)</span><br><span class="line">                res[k++] = matrix[down][j];</span><br><span class="line">            <span class="keyword">if</span>(--down &lt; up)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = down; i &gt;= up; i--)</span><br><span class="line">                res[k++] = matrix[i][left];</span><br><span class="line">            <span class="keyword">if</span>(++left &gt; right)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>jz-22</title>
    <url>/post/410084b.html</url>
    <content><![CDATA[<h1 id="剑指-Offer-22-链表中倒数第k个节点"><a href="#剑指-Offer-22-链表中倒数第k个节点" class="headerlink" title="剑指 Offer 22. 链表中倒数第k个节点"></a><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指 Offer 22. 链表中倒数第k个节点</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</span><br><span class="line"></span><br><span class="line">例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路：使用快慢指针，实现一次遍历，定位倒数第k个节点</p>
<p>注意边界条件：</p>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210511200431.png" alt="image-20210511200431654"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getKthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//快慢指针</span></span><br><span class="line">        ListNode fast = head , slow = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; k; i++)</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>jz-32-II</title>
    <url>/post/75aed020.html</url>
    <content><![CDATA[<h1 id="剑指-Offer-32-II-从上到下打印二叉树-II"><a href="#剑指-Offer-32-II-从上到下打印二叉树-II" class="headerlink" title="剑指 Offer 32 - II. 从上到下打印二叉树 II"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">剑指 Offer 32 - II. 从上到下打印二叉树 II</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路：简单层序遍历，使用队列</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="comment">//层序遍历使用队列</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Deque&lt;TreeNode&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode node = queue.pollFirst();</span><br><span class="line">                tmp.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)</span><br><span class="line">                    queue.addLast(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)</span><br><span class="line">                    queue.addLast(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tmp));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>jz-39</title>
    <url>/post/8ad9e082.html</url>
    <content><![CDATA[<h1 id="剑指-Offer-39-数组中出现次数超过一半的数字"><a href="#剑指-Offer-39-数组中出现次数超过一半的数字" class="headerlink" title="剑指 Offer 39. 数组中出现次数超过一半的数字"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/">剑指 Offer 39. 数组中出现次数超过一半的数字</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</span><br><span class="line">你可以假设数组是非空的，并且给定的数组总是存在多数元素。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路：</p>
<p>1）hashmap进行计数</p>
<p>2）数组排序取中位数</p>
<p>3）<strong>摩尔投票法</strong> ： 空间复杂度O(1) ， 时间复杂度O(n)</p>
<p><strong>摩尔投票法核心理念：票数正负抵消</strong></p>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210512160249.png" alt="image-20210512160249108"></p>
</blockquote>
<blockquote>
<p><strong>这里题中说众数一定存在，所以摩尔投票法不用验证，在未说明的情况下，摩尔投票法分为投票和计数两个阶段</strong>；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> major = nums[<span class="number">0</span>] , cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == major)</span><br><span class="line">            &#123;</span><br><span class="line">                cnt++;          <span class="comment">//投票，计数+1</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(--cnt == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                major = nums[i];</span><br><span class="line">                cnt = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> major;       <span class="comment">//最后保留下的一定是众数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>包含验证阶段：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> major = nums[<span class="number">0</span>] , cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//投票阶段</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == major)</span><br><span class="line">            &#123;</span><br><span class="line">                cnt++;          <span class="comment">//投票，计数+1</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(--cnt == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                major = nums[i];</span><br><span class="line">                cnt = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计数阶段（验证是否是众数）</span></span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(major == num)</span><br><span class="line">                cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt &gt; n / <span class="number">2</span> ? major : -<span class="number">1</span>;       <span class="comment">//最后保留下的一定是众数,或者众数不存在</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>jz-47</title>
    <url>/post/22205b42.html</url>
    <content><![CDATA[<h1 id="剑指-Offer-47-礼物的最大价值"><a href="#剑指-Offer-47-礼物的最大价值" class="headerlink" title="剑指 Offer 47. 礼物的最大价值"></a><a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">剑指 Offer 47. 礼物的最大价值</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路：dp，动态规划，</p>
<p>状态转移方程：dp[i][j] = max(dp[i][j-1] , dp[i-1][j]) + g[i][j];</p>
<p>边界条件：左边界和右边界</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp</span></span><br><span class="line">        <span class="keyword">int</span> m = grid.length , n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j-<span class="number">1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">        <span class="comment">//填表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j] , dp[i][j-<span class="number">1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];        <span class="comment">//最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>jz-48</title>
    <url>/post/b29f46d3.html</url>
    <content><![CDATA[<h1 id="剑指-Offer-48-最长不含重复字符的子字符串"><a href="#剑指-Offer-48-最长不含重复字符的子字符串" class="headerlink" title="剑指 Offer 48. 最长不含重复字符的子字符串"></a><a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">剑指 Offer 48. 最长不含重复字符的子字符串</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路1 ： 滑动窗口 + Set去重</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span> , r = <span class="number">0</span>;</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(r &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.contains(s.charAt(r)))</span><br><span class="line">            &#123;</span><br><span class="line">                set.add(s.charAt(r));   </span><br><span class="line">                r++;        </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(set.contains(s.charAt(r)))</span><br><span class="line">                &#123;</span><br><span class="line">                    set.remove(s.charAt(l++));    <span class="comment">//左指针滑动                </span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(max , r - l);    <span class="comment">//求长度</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; r &lt; s.length(); r++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(r);</span><br><span class="line">            <span class="keyword">while</span>(set.contains(c)) &#123;</span><br><span class="line">                set.remove(s.charAt(l++));</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(c);</span><br><span class="line">            res = Math.max(res, r - l + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路2 ： 动态规划 + 哈希表</p>
<ul>
<li>哈希表统计：各字符最后一次出现的索引位置</li>
<li>左边界i获取方式：通过访问哈希表获取</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character , Integer&gt; dic = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span> , tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s.length(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> i = dic.getOrDefault(s.charAt(j) , -<span class="number">1</span>); <span class="comment">//获取索引i</span></span><br><span class="line">            dic.put(s.charAt(j) , j);       <span class="comment">//更新哈希表</span></span><br><span class="line">            tmp = tmp &lt; j - i ? tmp + <span class="number">1</span> : j - i;</span><br><span class="line">            res = Math.max(res , tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
        <category>滑动窗口</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>jz-53-II</title>
    <url>/post/425242e5.html</url>
    <content><![CDATA[<h1 id="剑指-Offer-53-II-0～n-1中缺失的数字"><a href="#剑指-Offer-53-II-0～n-1中缺失的数字" class="headerlink" title="剑指 Offer 53 - II. 0～n-1中缺失的数字"></a><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/">剑指 Offer 53 - II. 0～n-1中缺失的数字</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210512173324.png" alt="image-20210512173323958"></p>
<hr>
<blockquote>
<p>思路：二分查找（排序数组中的搜索问题，首先考虑二分法解决）</p>
<p>根据题意，数组可以划分为：</p>
<ul>
<li>左子数组：nums[i]  == i</li>
<li>右子数组： nums[i] != i</li>
</ul>
<p>缺失数字等于右子数组的首位元素对应的索引，考虑使用二分法查找右子数组的首位元素。</p>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210512173650.png" alt="image-20210512173650518"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="comment">//二分</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = n;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;		<span class="comment">//向下取整除法</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; mid)</span><br><span class="line">            &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == mid)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210512173835.png" alt="image-20210512173835179"></p>
<hr>
<ul>
<li>暴力解法：</li>
</ul>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210512174015.png" alt="image-20210512174015396"></p>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>jz-56-II</title>
    <url>/post/758cb2d7.html</url>
    <content><![CDATA[<h1 id="剑指-Offer-56-II-数组中数字出现的次数-II"><a href="#剑指-Offer-56-II-数组中数字出现的次数-II" class="headerlink" title="剑指 Offer 56 - II. 数组中数字出现的次数 II"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/">剑指 Offer 56 - II. 数组中数字出现的次数 II</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h2><blockquote>
<p>思路1 ： 有限状态机FSM：</p>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210512170814.png" alt="image-20210512170814065"></p>
</blockquote>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210512170833.png" alt="image-20210512170833868"></p>
<hr>
<h2 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h2><p><strong>一个数组中一个数字出现1次，其余数字都出现m次，通用解法：对数组的每个元素的每一位进行求和，然后对m取模，剩下的值就是出现一次数字的值；</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>((nums[j] &amp; (<span class="number">1</span> &lt;&lt; i)) == (<span class="number">1</span> &lt;&lt; i))		<span class="comment">//注意这里的写法</span></span><br><span class="line">                    cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp[i] = cnt % <span class="number">3</span>;       <span class="comment">//取3的余数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp[i] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>















]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>jz-52</title>
    <url>/post/4b519e8c.html</url>
    <content><![CDATA[<h1 id="剑指-Offer-52-两个链表的第一个公共节点"><a href="#剑指-Offer-52-两个链表的第一个公共节点" class="headerlink" title="剑指 Offer 52. 两个链表的第一个公共节点"></a><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">剑指 Offer 52. 两个链表的第一个公共节点</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入两个链表，找出它们的第一个公共节点。</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210512180020.png" alt="image-20210512180020346"></p>
<hr>
<blockquote>
<p>思路：使用双指针</p>
<p>时间复杂度：<em>O</em>(<em>M</em>+<em>N</em>)</p>
<p>空间复杂度：O(1)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        ListNode p1 = headA , p2 = headB;</span><br><span class="line">        <span class="keyword">while</span>(p1 != p2)</span><br><span class="line">        &#123;</span><br><span class="line">            p1 = p1 != <span class="keyword">null</span> ? p1.next : headB;</span><br><span class="line">            p2 = p2 != <span class="keyword">null</span> ? p2.next : headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>















]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>jz-57</title>
    <url>/post/3b3b6a03.html</url>
    <content><![CDATA[<h1 id="剑指-Offer-57-和为s的两个数字"><a href="#剑指-Offer-57-和为s的两个数字" class="headerlink" title="剑指 Offer 57. 和为s的两个数字"></a><a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/">剑指 Offer 57. 和为s的两个数字</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路：数组是有序的，使用双指针进行搜索</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span> , right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)         <span class="comment">//left == right时必须跳出</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left] + nums[right] == target)</span><br><span class="line">            &#123;</span><br><span class="line">                res[<span class="number">0</span>] = nums[left];</span><br><span class="line">                res[<span class="number">1</span>] = nums[right];</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[left] + nums[right] &lt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>jz-58-I</title>
    <url>/post/e3e516a7.html</url>
    <content><![CDATA[<h1 id="剑指-Offer-58-I-翻转单词顺序"><a href="#剑指-Offer-58-I-翻转单词顺序" class="headerlink" title="剑指 Offer 58 - I. 翻转单词顺序"></a><a href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/">剑指 Offer 58 - I. 翻转单词顺序</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串&quot;I am a student. &quot;，则输出&quot;student. a am I&quot;。</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>lc-12</title>
    <url>/post/8d6cb63d.html</url>
    <content><![CDATA[<h1 id="12-整数转罗马数字"><a href="#12-整数转罗马数字" class="headerlink" title="12. 整数转罗马数字"></a><a href="https://leetcode-cn.com/problems/integer-to-roman/">12. 整数转罗马数字</a></h1><p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210514214908.png" alt="image-20210514214908480"></p>
<hr>
<blockquote>
<p>思路：模拟数字转换过程，贪心思想：我们每次使用最大的数来表示该整数；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//模拟</span></span><br><span class="line">        <span class="keyword">int</span>[] value = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1000</span> , <span class="number">900</span> , <span class="number">500</span> , <span class="number">400</span> , <span class="number">100</span> , <span class="number">90</span> , <span class="number">50</span> , <span class="number">40</span> , <span class="number">10</span> , <span class="number">9</span> , <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        String[] rom = &#123;<span class="string">&quot;M&quot;</span> , <span class="string">&quot;CM&quot;</span> , <span class="string">&quot;D&quot;</span> , <span class="string">&quot;CD&quot;</span> , <span class="string">&quot;C&quot;</span> , <span class="string">&quot;XC&quot;</span> , <span class="string">&quot;L&quot;</span> , <span class="string">&quot;XL&quot;</span> , <span class="string">&quot;X&quot;</span> , <span class="string">&quot;IX&quot;</span> , <span class="string">&quot;V&quot;</span> , <span class="string">&quot;IV&quot;</span> , <span class="string">&quot;I&quot;</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(num &gt;= value[i])</span><br><span class="line">            &#123;</span><br><span class="line">                sb.append(rom[i]);</span><br><span class="line">                num -= value[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路2：对数字进行硬编码</p>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210514215107.png" alt="image-20210514215107240"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    String[] thousands = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;M&quot;</span>, <span class="string">&quot;MM&quot;</span>, <span class="string">&quot;MMM&quot;</span>&#125;;</span><br><span class="line">    String[] hundreds  = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;CC&quot;</span>, <span class="string">&quot;CCC&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;DC&quot;</span>, <span class="string">&quot;DCC&quot;</span>, <span class="string">&quot;DCCC&quot;</span>, <span class="string">&quot;CM&quot;</span>&#125;;</span><br><span class="line">    String[] tens      = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;XX&quot;</span>, <span class="string">&quot;XXX&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;LX&quot;</span>, <span class="string">&quot;LXX&quot;</span>, <span class="string">&quot;LXXX&quot;</span>, <span class="string">&quot;XC&quot;</span>&#125;;</span><br><span class="line">    String[] ones      = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;I&quot;</span>, <span class="string">&quot;II&quot;</span>, <span class="string">&quot;III&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;VI&quot;</span>, <span class="string">&quot;VII&quot;</span>, <span class="string">&quot;VIII&quot;</span>, <span class="string">&quot;IX&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        StringBuffer roman = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        roman.append(thousands[num / <span class="number">1000</span>]);</span><br><span class="line">        roman.append(hundreds[num % <span class="number">1000</span> / <span class="number">100</span>]);</span><br><span class="line">        roman.append(tens[num % <span class="number">100</span> / <span class="number">10</span>]);</span><br><span class="line">        roman.append(ones[num % <span class="number">10</span>]);</span><br><span class="line">        <span class="keyword">return</span> roman.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>lc-100</title>
    <url>/post/9e089d04.html</url>
    <content><![CDATA[<h1 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100. 相同的树"></a><a href="https://leetcode-cn.com/problems/same-tree/">100. 相同的树</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。</span><br><span class="line"></span><br><span class="line">如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> || q == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> p.val == q.val &amp;&amp; isSameTree(p.left , q.left) &amp;&amp; isSameTree(p.right , q.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>jz-58-II</title>
    <url>/post/9553c5e4.html</url>
    <content><![CDATA[<h1 id="剑指-Offer-58-II-左旋转字符串"><a href="#剑指-Offer-58-II-左旋转字符串" class="headerlink" title="剑指 Offer 58 - II. 左旋转字符串"></a><a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">剑指 Offer 58 - II. 左旋转字符串</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串&quot;abcdefg&quot;和数字2，该函数将返回左旋转两位得到的结果&quot;cdefgab&quot;。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>写法1：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseLeftWords</span><span class="params">(String s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        String s1 = s.substring(<span class="number">0</span>, n);</span><br><span class="line">        String s2 = s.substring(n);</span><br><span class="line">        <span class="keyword">return</span> s2 + s1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>写法2：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseLeftWords</span><span class="params">(String s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &lt; n + s.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sb.append(s.charAt(i % s.length()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>写法3：</p>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210514220337.png" alt="image-20210514220337393"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseLeftWords</span><span class="params">(String s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m =s.length();</span><br><span class="line">        s += s;</span><br><span class="line">        <span class="keyword">return</span> s.substring(n, n + m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>写法4：原地操作法(不消耗额外内存)：<strong>先将字符串前半部分逆置，然后将后半部分逆置，最后整体逆置</strong>；（<strong>三次翻转，经典解法</strong>）</p>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210514221132.png" alt="image-20210514221132291"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseLeftWords</span><span class="params">(String s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] ss = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="comment">//三次翻转</span></span><br><span class="line">        reverse(ss, <span class="number">0</span> , n - <span class="number">1</span>);</span><br><span class="line">        reverse(ss, n , len - <span class="number">1</span>);</span><br><span class="line">        reverse(ss, <span class="number">0</span> , len - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(ss);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] chars , <span class="keyword">int</span> i , <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> tmp = chars[i];</span><br><span class="line">            chars[i] = chars[j];</span><br><span class="line">            chars[j] = tmp;</span><br><span class="line">            i++; j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



















]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>lc-1269</title>
    <url>/post/df2ad8e9.html</url>
    <content><![CDATA[<h1 id="1269-停在原地的方案数"><a href="#1269-停在原地的方案数" class="headerlink" title="1269. 停在原地的方案数"></a><a href="https://leetcode-cn.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/">1269. 停在原地的方案数</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有一个长度为 arrLen 的数组，开始有一个指针在索引 0 处。</span><br><span class="line"></span><br><span class="line">每一步操作中，你可以将指针向左或向右移动 1 步，或者停在原地（指针不能被移动到数组范围外）。</span><br><span class="line"></span><br><span class="line">给你两个整数 steps 和 arrLen ，请你计算并返回：在恰好执行 steps 次操作以后，指针仍然指向索引 0 处的方案数。</span><br><span class="line"></span><br><span class="line">由于答案可能会很大，请返回方案数 模 10^9 + 7 后的结果。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路1 ： 动态规划，状态定义：dp[i][j]  :  第i步操作，位于位置j的方案数</p>
<p>状态转移方程： dp[i][j] = dp[i-1][j]  +  dp[i-1][j-1] + dp[i-1][j+1]</p>
<p>base case : dp[0][0] = 1;</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> steps, <span class="keyword">int</span> arrLen)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> col = Math.min(arrLen - <span class="number">1</span>, steps);</span><br><span class="line">        <span class="comment">//dp[i][j] 第i步操作后，位于位置j的方案数</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[steps + <span class="number">1</span>][col + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> Mod = (<span class="keyword">int</span>)<span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="comment">//base case </span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= steps; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= col; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j] % Mod;  <span class="comment">//不动</span></span><br><span class="line">                <span class="keyword">if</span>(j - <span class="number">1</span> &gt;= <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = (dp[i][j] + dp[i-<span class="number">1</span>][j-<span class="number">1</span>]) % Mod;</span><br><span class="line">                <span class="keyword">if</span>(j + <span class="number">1</span> &lt;= col)</span><br><span class="line">                    dp[i][j] = (dp[i][j] + dp[i-<span class="number">1</span>][j+<span class="number">1</span>]) % Mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[steps][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路2：回溯搜索 + 备忘录+剪枝:</p>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210513160257.png" alt="image-20210513160256931"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> Mod = <span class="number">1_000_000_007</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> steps, <span class="keyword">int</span> arrLen)</span> </span>&#123;</span><br><span class="line">        Map&lt;String , Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> backtrack(steps , arrLen , <span class="number">0</span> , map);   <span class="comment">//从左上角开始走</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> steps , <span class="keyword">int</span> arrLen , <span class="keyword">int</span> i , Map&lt;String , Integer&gt; map)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(steps == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String key = steps + <span class="string">&quot;*&quot;</span> + i;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(key))	 <span class="comment">//首先判断是否计算过，如果计算过就从map中取</span></span><br><span class="line">            <span class="keyword">return</span> map.get(key);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(steps &lt; i)           <span class="comment">//剪枝（必然无法返回的情况）</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>)res;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span>)</span><br><span class="line">            res += backtrack(steps - <span class="number">1</span> , arrLen , i - <span class="number">1</span> , map) % Mod;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; arrLen - <span class="number">1</span>)</span><br><span class="line">            res += backtrack(steps - <span class="number">1</span> , arrLen , i + <span class="number">1</span> , map) % Mod;</span><br><span class="line">        res += backtrack(steps - <span class="number">1</span> , arrLen , i , map) % Mod;</span><br><span class="line">        res = res % Mod;</span><br><span class="line">        map.put(key , (<span class="keyword">int</span>)res);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



















]]></content>
      <categories>
        <category>每日一题</category>
        <category>动态规划</category>
        <category>回溯</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
        <tag>回溯</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>lc-1310</title>
    <url>/post/e8759cbd.html</url>
    <content><![CDATA[<h1 id="1310-子数组异或查询"><a href="#1310-子数组异或查询" class="headerlink" title="1310. 子数组异或查询"></a><a href="https://leetcode-cn.com/problems/xor-queries-of-a-subarray/">1310. 子数组异或查询</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有一个正整数数组 arr，现给你一个对应的查询数组 queries，其中 queries[i] &#x3D; [Li, Ri]。</span><br><span class="line"></span><br><span class="line">对于每个查询 i，请你计算从 Li 到 Ri 的 XOR 值（即 arr[Li] xor arr[Li+1] xor ... xor arr[Ri]）作为本次查询的结果。</span><br><span class="line"></span><br><span class="line">并返回一个包含给定查询 queries 所有结果的数组。</span><br><span class="line"></span><br><span class="line">1 &lt;&#x3D; arr.length &lt;&#x3D; 3 * 10^4</span><br><span class="line">1 &lt;&#x3D; arr[i] &lt;&#x3D; 10^9</span><br><span class="line">1 &lt;&#x3D; queries.length &lt;&#x3D; 3 * 10^4</span><br><span class="line">queries[i].length &#x3D;&#x3D; 2</span><br><span class="line">0 &lt;&#x3D; queries[i][0] &lt;&#x3D; queries[i][1] &lt; arr.length</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路1 ： 暴力求解，，效率低，，有超时风险</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] xorQueries(<span class="keyword">int</span>[] arr, <span class="keyword">int</span>[][] queries) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = queries.length;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = queries[i][<span class="number">0</span>]; j &lt;= queries[i][<span class="number">1</span>]; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                res[i] ^= arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路2：前缀和优化，去除重复计算；</p>
<p>前缀和数组prefix比原数组容量大1；</p>
<p><strong>利用前缀和实现区间范围内的快速计算</strong></p>
<p>注意数组下标对应关系</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] xorQueries(<span class="keyword">int</span>[] arr, <span class="keyword">int</span>[][] queries) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        <span class="keyword">int</span>[] prefix = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//计算前缀异或和数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            prefix[i] = prefix[i-<span class="number">1</span>] ^ arr[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = queries.length;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a = queries[i][<span class="number">0</span>] , b = queries[i][<span class="number">1</span>];</span><br><span class="line">            res[i] = prefix[b + <span class="number">1</span>] ^ prefix[(a + <span class="number">1</span>) - <span class="number">1</span>];       <span class="comment">//注意数组下标对应关系</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>lc-13</title>
    <url>/post/fa6b86ab.html</url>
    <content><![CDATA[<h1 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13. 罗马数字转整数"></a><a href="https://leetcode-cn.com/problems/roman-to-integer/">13. 罗马数字转整数</a></h1><p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210515144317.png" alt="image-20210515144317830"></p>
<hr>
<blockquote>
<p>思路：模拟，首先建立符合和数字的Map映射，然后从左到右遍历字符串，如果当前字符代表值不小于右边，就加上该值，否则就减去该值，以此类推，直到遍历完</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character , Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;()&#123;</span><br><span class="line">            &#123;</span><br><span class="line">                put(<span class="string">&#x27;I&#x27;</span> , <span class="number">1</span>);</span><br><span class="line">                put(<span class="string">&#x27;V&#x27;</span> , <span class="number">5</span>);</span><br><span class="line">                put(<span class="string">&#x27;X&#x27;</span> , <span class="number">10</span>);</span><br><span class="line">                put(<span class="string">&#x27;L&#x27;</span> , <span class="number">50</span>);</span><br><span class="line">                put(<span class="string">&#x27;C&#x27;</span> , <span class="number">100</span>);</span><br><span class="line">                put(<span class="string">&#x27;D&#x27;</span> , <span class="number">500</span>);</span><br><span class="line">                put(<span class="string">&#x27;M&#x27;</span> , <span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> val = map.get(s.charAt(i));</span><br><span class="line">            <span class="keyword">if</span>(i + <span class="number">1</span> &lt; n &amp;&amp; val &lt; map.get(s.charAt(i+<span class="number">1</span>)))</span><br><span class="line">            &#123;</span><br><span class="line">                res -= val;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res += val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>lc-14</title>
    <url>/post/640f1308.html</url>
    <content><![CDATA[<h1 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a><a href="https://leetcode-cn.com/problems/longest-common-prefix/">14. 最长公共前缀</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">编写一个函数来查找字符串数组中的最长公共前缀。</span><br><span class="line"></span><br><span class="line">如果不存在公共前缀，返回空字符串 &quot;&quot;。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路1 : 纵向模拟</p>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210515152101.png" alt="image-20210515152101628"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> n = strs.length , i = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">while</span>(i &lt; strs[<span class="number">0</span>].length())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> c = strs[<span class="number">0</span>].charAt(i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(strs[j].length() == i || strs[j].charAt(i) != c)</span><br><span class="line">                    <span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span> , i);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路2：横向模拟</p>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210515152826.png" alt="image-20210515152826352"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> n = strs.length;</span><br><span class="line">        String prefix = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            prefix = longsubstr(prefix , strs[i]);</span><br><span class="line">            <span class="keyword">if</span>(prefix.length() == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">longsubstr</span><span class="params">(String s1 , String s2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = s1.length() , n2 = s2.length();</span><br><span class="line">        <span class="keyword">int</span> n = Math.min(n1 , n2);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s1.charAt(i) != s2.charAt(i))</span><br><span class="line">                <span class="keyword">return</span> s1.substring(<span class="number">0</span>,i);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n1 &lt; n2 ? s1 : s2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//写法2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> n = strs.length;</span><br><span class="line">        String prefix = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            prefix = longsubstr(prefix , strs[i]);</span><br><span class="line">            <span class="keyword">if</span>(prefix.length() == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">longsubstr</span><span class="params">(String s1 , String s2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = Math.min(s1.length() , s2.length());</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n &amp;&amp; s1.charAt(i) == s2.charAt(i))</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s1.substring(<span class="number">0</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>lc-1482</title>
    <url>/post/d2f6505d.html</url>
    <content><![CDATA[<h1 id="1482-制作-m-束花所需的最少天数"><a href="#1482-制作-m-束花所需的最少天数" class="headerlink" title="1482. 制作 m 束花所需的最少天数"></a><a href="https://leetcode-cn.com/problems/minimum-number-of-days-to-make-m-bouquets/">1482. 制作 m 束花所需的最少天数</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给你一个整数数组 bloomDay，以及两个整数 m 和 k 。</span><br><span class="line"></span><br><span class="line">现需要制作 m 束花。制作花束时，需要使用花园中 相邻的 k 朵花 。</span><br><span class="line"></span><br><span class="line">花园中有 n 朵花，第 i 朵花会在 bloomDay[i] 时盛开，恰好 可以用于 一束 花中。</span><br><span class="line"></span><br><span class="line">请你返回从花园中摘 m 束花需要等待的最少的天数。如果不能摘到 m 束花则返回 -1 。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路：二分查找，首先确定等待天数的上下边界，然后二分搜索，确定范围</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDays</span><span class="params">(<span class="keyword">int</span>[] bloomDay, <span class="keyword">int</span> m, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = bloomDay.length;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; m * k)       <span class="comment">//花数不够</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE , max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="comment">//找出上下边界</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            min = Math.min(min ,bloomDay[i]);</span><br><span class="line">            max = Math.max(max , bloomDay[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = min , right = max;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)     <span class="comment">//二分查找</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(bloomDay , k , m , mid))</span><br><span class="line">            &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span>[] bloomDay , <span class="keyword">int</span> k ,<span class="keyword">int</span> m, <span class="keyword">int</span> day)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//计算等待花开天数是否能够产生m朵花</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span> , num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bloomDay.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(bloomDay[i] &lt;= day)      <span class="comment">//可以成熟的花</span></span><br><span class="line">            &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="keyword">if</span>(cnt &gt;= k)    <span class="comment">//可以制作一束花</span></span><br><span class="line">                &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                    cnt = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cnt = <span class="number">0</span>;        <span class="comment">//清0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num &gt;= m;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>lc-229</title>
    <url>/post/d7a4f97b.html</url>
    <content><![CDATA[<h1 id="229-求众数-II"><a href="#229-求众数-II" class="headerlink" title="229. 求众数 II"></a><a href="https://leetcode-cn.com/problems/majority-element-ii/">229. 求众数 II</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个大小为 n 的整数数组，找出其中所有出现超过 ⌊ n&#x2F;3 ⌋ 次的元素。</span><br><span class="line"></span><br><span class="line">进阶：尝试设计时间复杂度为 O(n)、空间复杂度为 O(1)的算法解决此问题。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路1 ： 使用HashMap进行计数，，实现略</p>
</blockquote>
<hr>
<blockquote>
<p>思路2 ： 摩尔计数法：求超过 ⌊ n/3 ⌋ 次的元素，则最多只有2个元素，<strong>则其可能存在，也可能不存在</strong>，<strong>需要进行验证</strong>；</p>
<p>求超过 ⌊ n/m ⌋次的元素，则最多只有m-1个元素，因此至多选m-1个代表进行判断；</p>
<p>此处选2个代表进行判断既可，最后进行计数验证，对符合条件的代表进行返回；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> major1 = <span class="number">0</span> , cnt1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> major2 = <span class="number">0</span> , cnt2 = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//投票阶段</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(major1 == nums[i])</span><br><span class="line">            &#123;</span><br><span class="line">                cnt1++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(major2 == nums[i])</span><br><span class="line">            &#123;</span><br><span class="line">                cnt2++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt1 == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                major1 = nums[i];</span><br><span class="line">                cnt1++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt2 == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                major2 = nums[i];</span><br><span class="line">                cnt2++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//和major1 , major2 均不同，将二者计数减1</span></span><br><span class="line">            cnt1--;</span><br><span class="line">            cnt2--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计数阶段（验证）</span></span><br><span class="line">        cnt1 = cnt2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(major1 == num)</span><br><span class="line">                cnt1++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(major2 == num)</span><br><span class="line">                cnt2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt1 &gt; n / <span class="number">3</span>)</span><br><span class="line">            res.add(major1);</span><br><span class="line">        <span class="keyword">if</span>(cnt2 &gt; n / <span class="number">3</span>)</span><br><span class="line">            res.add(major2);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>摩尔投票法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>摩尔投票法</tag>
      </tags>
  </entry>
  <entry>
    <title>lc-206</title>
    <url>/post/752d8668.html</url>
    <content><![CDATA[<h1 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路1：递归写法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode newhead = reverseList(head.next);</span><br><span class="line">        ListNode cur = newhead;</span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="keyword">null</span>)</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        cur.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> newhead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>递归写法2：</p>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210515174221.png" alt="image-20210515174221845"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode newhead = reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> newhead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路2 ： 迭代求解，设置三个指针：pre  ,  cur ,  next</p>
<p>画图分析反转过程</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span> , cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode next = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>链表</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>lc-24</title>
    <url>/post/4f2240cb.html</url>
    <content><![CDATA[<h1 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</span><br><span class="line"></span><br><span class="line">你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路1：递归实现</p>
<p>递归终止条件：当链表中没有结点或只有一个结点无法交换时，返回</p>
<p>时间复杂度：O(n) : n是链表的节点数量，需要对每个节点进行更新操作</p>
<p>空间复杂度: O(n) ，n表示链表的节点数量，空间复杂度取决于递归调用的栈空间；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)   <span class="comment">//递归终止条件</span></span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode newhead = head.next;</span><br><span class="line">        head.next = swapPairs(newhead.next);</span><br><span class="line">        newhead.next = head;</span><br><span class="line">        <span class="keyword">return</span> newhead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<blockquote>
<p>思路2：迭代实现，链表，设置哑结点，统一操作；</p>
<p>画图分析具体的迭代实现，，，</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode cur = dummy;</span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="keyword">null</span> &amp;&amp; cur.next.next != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode node1 = cur.next;</span><br><span class="line">            ListNode node2 = cur.next.next;</span><br><span class="line">            cur.next = node2;</span><br><span class="line">            node1.next = node2.next;</span><br><span class="line">            node2.next = node1;</span><br><span class="line">            cur = node1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>链表</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>lc-25</title>
    <url>/post/3825705d.html</url>
    <content><![CDATA[<h1 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</span><br><span class="line"></span><br><span class="line">k 是一个正整数，它的值小于或等于链表的长度。</span><br><span class="line"></span><br><span class="line">如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</span><br><span class="line"></span><br><span class="line">进阶：</span><br><span class="line"></span><br><span class="line">你可以设计一个只使用常数额外空间的算法来解决此问题吗？</span><br><span class="line">你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210515180406.png" alt="image-20210515180406035"></p>
<hr>
<blockquote>
<p>思路：<strong>将链表结点按照长度k进行分组，每一组内进行链表反转操作；</strong></p>
<p>为了统一形式，对第一个节点前添加一个哑结点；</p>
<p><strong>使用2个辅助结点来标记当前组的前一个结点和后一个结点</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode pre= dummy;</span><br><span class="line">        ListNode end = dummy;</span><br><span class="line">        <span class="keyword">while</span>(end.next != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k &amp;&amp; end != <span class="keyword">null</span>; i++)</span><br><span class="line">                end = end.next;</span><br><span class="line">            <span class="keyword">if</span>(end == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            ListNode start = pre.next;</span><br><span class="line">            ListNode next = end.next;</span><br><span class="line">            end.next = <span class="keyword">null</span>;</span><br><span class="line">            pre.next = reverse(start);</span><br><span class="line">            start.next = next;</span><br><span class="line">            pre = start;</span><br><span class="line"></span><br><span class="line">            end = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//反转链表</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode next = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>链表</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>lc-421</title>
    <url>/post/ddf20dfb.html</url>
    <content><![CDATA[<h1 id="421-数组中两个数的最大异或值"><a href="#421-数组中两个数的最大异或值" class="headerlink" title="421. 数组中两个数的最大异或值"></a><a href="https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/">421. 数组中两个数的最大异或值</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给你一个整数数组 nums ，返回 nums[i] XOR nums[j] 的最大运算结果，其中 0 ≤ i ≤ j &lt; n 。</span><br><span class="line"></span><br><span class="line">进阶：你可以在 O(n) 的时间解决这个问题吗？</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路：朴素解法1：暴力遍历，时间复杂度：O(n^2)</p>
<p>优化：2个数进行异或的最大值不超过2个数之和，将数组从小到大排序后，从后向前遍历，如果两数相加小于max，则不用再遍历，直接跳出</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(nums);      <span class="comment">//数组先排序</span></span><br><span class="line">        <span class="keyword">long</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n-<span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>((<span class="keyword">long</span>)nums[i] + (<span class="keyword">long</span>)nums[j] &lt;= max)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                max = Math.max(max , (<span class="keyword">long</span>)(nums[i] ^ nums[j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路2：O(n)时间复杂度解法：使用字典树 Trie+ 贪心优化</p>
<p>遍历字典树，尽量维持当前选择的方向能保证当前位异或结果为1</p>
<p><strong>贪心：优先保证高位的数异或为1</strong></p>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210516203712.png" alt="image-20210516203711948"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//字典树根结点</span></span><br><span class="line">    Trie root = <span class="keyword">new</span> Trie();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HIGH_BIT = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            add(nums[i-<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">//将nums[i]看作ai,找到最大的x更新答案</span></span><br><span class="line">            x = Math.max(x , check(nums[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        Trie cur = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; k--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> bit = (num &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(bit == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(cur.left == <span class="keyword">null</span>)</span><br><span class="line">                    cur.left = <span class="keyword">new</span> Trie();</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(cur.right == <span class="keyword">null</span>)</span><br><span class="line">                    cur.right = <span class="keyword">new</span> Trie();</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Trie cur = root;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; k--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> bit= (num &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(bit == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//a[i]的第k个二进制位为0，表示应该向1的子节点走</span></span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="keyword">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                    x = <span class="number">2</span> * x + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    x = x * <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//a[i]的第k个二进制位为1，表示应该向0的子节点走</span></span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    x = <span class="number">2</span> * x + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                    x = x * <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Trie</span></span>&#123;</span><br><span class="line">        Trie left = <span class="keyword">null</span>;   <span class="comment">//左子树指向表示0的节点</span></span><br><span class="line">        Trie right = <span class="keyword">null</span>;  <span class="comment">//右子树指向1的子节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Trie root = <span class="keyword">new</span> Trie();</span><br><span class="line">    <span class="keyword">int</span> highbit = <span class="number">30</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            add(nums[i]);</span><br><span class="line">            res = Math.max(res , check(nums[i+<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Trie cur = root;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = highbit; i &gt;= <span class="number">0</span>; i--)       <span class="comment">//贪心思想</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> bit = (num &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(bit == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//向右走</span></span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="keyword">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                    res = res * <span class="number">2</span> + <span class="number">1</span>;  <span class="comment">//异或+1</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    res = res * <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//向左走</span></span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    res = res * <span class="number">2</span> + <span class="number">1</span>;  <span class="comment">//异或+1</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                    res = res * <span class="number">2</span>;  </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Trie cur = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = highbit; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> bit = (num &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(bit == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//左子树</span></span><br><span class="line">                <span class="keyword">if</span>(cur.left == <span class="keyword">null</span>)</span><br><span class="line">                    cur.left = <span class="keyword">new</span> Trie();</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//右子树</span></span><br><span class="line">                <span class="keyword">if</span>(cur.right == <span class="keyword">null</span>)</span><br><span class="line">                    cur.right = <span class="keyword">new</span> Trie();</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Trie</span></span>&#123;</span><br><span class="line">        Trie left = <span class="keyword">null</span>;   <span class="comment">//左子树--0</span></span><br><span class="line">        Trie right = <span class="keyword">null</span>;  <span class="comment">//右子树--0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>每日一题</category>
        <category>字典树</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>lc-46</title>
    <url>/post/f7768661.html</url>
    <content><![CDATA[<h1 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路：回溯  + 剪枝</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        backtrack(nums , path);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums , LinkedList&lt;Integer&gt; path)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size() == nums.length)</span><br><span class="line">        &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> LinkedList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(path.contains(nums[j]))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            path.add(nums[j]);</span><br><span class="line">            backtrack(nums , path);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>回溯</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>lc-52</title>
    <url>/post/e9007339.html</url>
    <content><![CDATA[<h1 id="52-N皇后-II"><a href="#52-N皇后-II" class="headerlink" title="52. N皇后 II"></a><a href="https://leetcode-cn.com/problems/n-queens-ii/">52. N皇后 II</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</span><br><span class="line"></span><br><span class="line">给你一个整数 n ，返回 n 皇后问题 不同的解决方案的数量。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路：使用回溯算法：套用回溯模板</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] nums = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] e : nums)</span><br><span class="line">            Arrays.fill(e , <span class="number">0</span>);</span><br><span class="line">        backtrack(nums, n , <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[][] nums , <span class="keyword">int</span> n , <span class="keyword">int</span> row)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row == n)</span><br><span class="line">        &#123;</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!check(nums, n , row , i))   <span class="comment">//当前位置不能放,剪枝</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            nums[row][i] = <span class="number">1</span>;</span><br><span class="line">            backtrack(nums , n , row + <span class="number">1</span>);</span><br><span class="line">            nums[row][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span>[][] nums , <span class="keyword">int</span> n , <span class="keyword">int</span> row , <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//当前列无皇后</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; row; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j][col] == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左上角无皇后</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = row , j = col; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i][j] == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右上角无皇后</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = row , j = col; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i-- , j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i][j] == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





































]]></content>
      <categories>
        <category>回溯</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>noip2010乌龟棋</title>
    <url>/post/a8d8a465.html</url>
    <content><![CDATA[<h1 id="noip2010-乌龟棋"><a href="#noip2010-乌龟棋" class="headerlink" title="noip2010 乌龟棋"></a><a href="https://www.cnblogs.com/jason2003/p/10339633.html">noip2010 乌龟棋</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">乌龟棋的棋盘是一行N个格子，每个格子上一个分数（非负整数）。棋盘第1格是唯一的起点，第N格是终点，游戏要求玩家控制一个乌龟棋子从起点出发走到终点。</span><br><span class="line"></span><br><span class="line">乌龟棋中M张爬行卡片，分成4种不同的类型（MM张卡片中不一定包含所有44种类型的卡片，见样例），每种类型的卡片上分别标有1,2,3,41,2,3,4四个数字之一，表示使用这种卡片后，乌龟棋子将向前爬行相应的格子数。游戏中，玩家每次需要从所有的爬行卡片中选择一张之前没有使用过的爬行卡片，控制乌龟棋子前进相应的格子数，每张卡片只能使用一次。</span><br><span class="line"></span><br><span class="line">游戏中，乌龟棋子自动获得起点格子的分数，并且在后续的爬行中每到达一个格子，就得到该格子相应的分数。玩家最终游戏得分就是乌龟棋子从起点到终点过程中到过的所有格子的分数总和。</span><br><span class="line"></span><br><span class="line">很明显，用不同的爬行卡片使用顺序会使得最终游戏的得分不同，小明想要找到一种卡片使用顺序使得最终游戏得分最多。</span><br><span class="line"></span><br><span class="line">现在，告诉你棋盘上每个格子的分数和所有的爬行卡片，你能告诉小明，他最多能得到多少分吗？</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>思路：<strong>多维DP</strong>：</p>
<p><img src="https://gitee.com/hellohakelh/mypicbed/raw/master/img/20210513213841.png" alt="image-20210513213838715"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define MAXN 10010</span><br><span class="line">#define in(a) a=read()</span><br><span class="line">#define REP(i,k,n)  for(int i=k;i&lt;=n;i++)</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="function">inline <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">for</span>(;!isdigit(ch);ch=getchar())</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            f=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;isdigit(ch);ch=getchar())</span><br><span class="line">        x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a,b,c,d;</span><br><span class="line"><span class="keyword">int</span> v[<span class="number">500</span>],n,m;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">50</span>][<span class="number">50</span>][<span class="number">50</span>][<span class="number">50</span>]; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    in(n),in(m);</span><br><span class="line">    REP(i,<span class="number">1</span>,n)  in(v[i]);</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    REP(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        in(x);</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">1</span>) a++;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">2</span>) b++;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">3</span>) c++;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">4</span>) d++;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=v[<span class="number">1</span>];</span><br><span class="line">    REP(i,<span class="number">0</span>,a)</span><br><span class="line">        REP(j,<span class="number">0</span>,b)</span><br><span class="line">            REP(k,<span class="number">0</span>,c)</span><br><span class="line">                REP(l,<span class="number">0</span>,d)&#123;</span><br><span class="line">                    <span class="keyword">int</span> r=<span class="number">1</span>+i+j*<span class="number">2</span>+k*<span class="number">3</span>+l*<span class="number">4</span>; </span><br><span class="line">                    <span class="keyword">if</span>(i!=<span class="number">0</span>) dp[i][j][k][l]=max(dp[i][j][k][l],dp[i-<span class="number">1</span>][j][k][l]+v[r]);</span><br><span class="line">                    <span class="keyword">if</span>(j!=<span class="number">0</span>) dp[i][j][k][l]=max(dp[i][j][k][l],dp[i][j-<span class="number">1</span>][k][l]+v[r]);</span><br><span class="line">                    <span class="keyword">if</span>(k!=<span class="number">0</span>) dp[i][j][k][l]=max(dp[i][j][k][l],dp[i][j][k-<span class="number">1</span>][l]+v[r]);</span><br><span class="line">                    <span class="keyword">if</span>(l!=<span class="number">0</span>) dp[i][j][k][l]=max(dp[i][j][k][l],dp[i][j][k][l-<span class="number">1</span>]+v[r]);</span><br><span class="line">                &#125;</span><br><span class="line">    cout&lt;&lt;dp[a][b][c][d];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
</search>
